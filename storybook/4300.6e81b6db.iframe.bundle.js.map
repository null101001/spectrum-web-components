{"version":3,"file":"4300.6e81b6db.iframe.bundle.js","mappings":";;AACA;;AAsYA;AACA;;;AAIA;;;;;;;AAiBA;AAQA;;;;AAIA;AACA;;AAEA;;;AAGA;;AAIA;;AAmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AAOA;;;AAIA;;AAWA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAIA;;AAEA;;AAEA;AACA;AAEA;;;;;AA2GA;;;AAIA;AAUA;AAEA;;;;AAOA;;AAEA;;AAIA;;;;AAMA;AACA;;AAEA;;AAGA;;;AAqBA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;;AC3tBA;AACA;;AAEA;;;AAGA;;;;;;;;;;;ACRA;;ACEA;AACA;;AAEA;;;AAGA","sources":["webpack://@spectrum-web-components/1st-gen/./packages/action-menu/src/ActionMenu.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-workflow/src/icons-s2/More.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-workflow/src/elements/IconMore.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-workflow/src/icons/More.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing,\n  SizedMixin\n} from \"@spectrum-web-components/base\";\nimport { state } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport {\n  ifDefined,\n  styleMap\n} from \"@spectrum-web-components/base/src/directives.js\";\nimport { SlottableRequestEvent } from \"@spectrum-web-components/overlay/src/slottable-request-event.js\";\nimport {\n  DESCRIPTION_ID,\n  ExpandableElement\n} from \"@spectrum-web-components/picker\";\nimport { ObserveSlotPresence } from \"@spectrum-web-components/shared/src/observe-slot-presence.js\";\nimport { ObserveSlotText } from \"@spectrum-web-components/shared/src/observe-slot-text.js\";\nimport \"@spectrum-web-components/action-button/sp-action-button.js\";\nimport \"@spectrum-web-components/icons-workflow/icons/sp-icon-more.js\";\nimport actionMenuStyles from \"./action-menu.css.js\";\nexport class ActionMenu extends ObserveSlotPresence(\n  ObserveSlotText(\n    SizedMixin(ExpandableElement, { noDefaultSize: true }),\n    \"label\"\n  ),\n  '[slot=\"label-only\"]'\n) {\n  constructor() {\n    super(...arguments);\n    this.selects = void 0;\n    /**\n     * @deprecated Reference to a legacy `<sp-menu>` child element.\n     * Used for backwards compatibility with older usage patterns.\n     */\n    this.deprecatedMenu = null;\n    this.invalid = false;\n    this.pendingLabel = \"Pending\";\n    this.quiet = false;\n    this.value = \"\";\n    /** The ARIA role for the menu list element. Uses 'menu' for action menus. */\n    this.listRole = \"menu\";\n    /** The ARIA role for individual menu items. Uses 'menuitem' for action menus. */\n    this.itemRole = \"menuitem\";\n    /**\n     * Handles Escape key press to close the picker overlay.\n     *\n     * @param event - The keyboard event\n     */\n    this.handleEscape = (event) => {\n      if (event.key === \"Escape\" && this.open) {\n        event.stopPropagation();\n        event.preventDefault();\n        this.toggle(false);\n      }\n    };\n    /**\n     * Handles keyboard navigation on the picker button.\n     * Opens the menu on Arrow keys, Enter, or Space.\n     *\n     * @param event - The keyboard event\n     */\n    this.handleKeydown = (event) => {\n      this.focused = true;\n      if (![\"ArrowUp\", \"ArrowDown\", \"Enter\", \" \", \"Escape\"].includes(event.key)) {\n        return;\n      }\n      if (event.key === \"Escape\") {\n        this.handleEscape(event);\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      this.keyboardOpen();\n    };\n    /**\n     * Callback invoked by an associated field label to apply its label value.\n     * Sets the applied label and determines label alignment based on the field label's configuration.\n     *\n     * @param value - The label text value\n     * @param labelElement - The field label element providing the label\n     */\n    this.applyFocusElementLabel = (value, labelElement) => {\n      this.appliedLabel = value;\n      this.labelAlignment = labelElement.sideAligned ? \"inline\" : void 0;\n    };\n    /** Tracks whether the overlay has been rendered at least once. */\n    this.hasRenderedOverlay = false;\n    /** Tracks whether a selection change is already scheduled for the next frame. */\n    this.willManageSelection = false;\n    /** Promise that resolves when selection management is complete. */\n    this.selectionPromise = Promise.resolve();\n    /**\n     * Tracks whether the component was recently connected to the DOM.\n     * Used to handle timing differences in Safari and Firefox.\n     */\n    this.recentlyConnected = false;\n    /** Tracks the target of an active Enter keydown to prevent double-activation. */\n    this.enterKeydownOn = null;\n    /**\n     * Handles Enter key events to prevent double-activation of menu items.\n     * Tracks keydown state and clears it on keyup.\n     * Also prevents Enter from triggering submenus that aren't open.\n     *\n     * @param event - The keyboard event\n     */\n    this.handleEnterKeydown = (event) => {\n      if (event.key !== \"Enter\") {\n        return;\n      }\n      const target = event == null ? void 0 : event.target;\n      if (!target.open && target.hasSubmenu) {\n        event.preventDefault();\n        return;\n      }\n      if (this.enterKeydownOn) {\n        event.preventDefault();\n        return;\n      }\n      this.enterKeydownOn = event.target;\n      this.addEventListener(\n        \"keyup\",\n        async (keyupEvent) => {\n          if (keyupEvent.key !== \"Enter\") {\n            return;\n          }\n          this.enterKeydownOn = null;\n        },\n        { once: true }\n      );\n    };\n    /**\n     * Handles slottable request events by re-dispatching them.\n     * Allows parent components to intercept overlay content requests.\n     *\n     * @param event - The slottable request event\n     */\n    this.handleSlottableRequest = (event) => {\n      this.dispatchEvent(new SlottableRequestEvent(event.name, event.data));\n    };\n  }\n  /**\n   * Returns the component's styles including action menu specific styles.\n   */\n  static get styles() {\n    return [actionMenuStyles];\n  }\n  /**\n   * Returns the list of menu items contained in the picker's options menu.\n   */\n  get menuItems() {\n    return this.optionsMenu.childItems;\n  }\n  /**\n   * @deprecated This property always returns true and will be removed in a future version.\n   */\n  get selfManageFocusElement() {\n    return true;\n  }\n  get selectedItem() {\n    return this._selectedItem;\n  }\n  /**\n   * Programmatically applies visible focus styling to the picker.\n   * Has no effect when the picker is disabled.\n   */\n  forceFocusVisible() {\n    if (this.disabled) {\n      return;\n    }\n    this.focused = true;\n  }\n  /**\n   * Toggles the picker's open state when called programmatically.\n   * Note: Pointer events are handled by the interaction controller.\n   */\n  click() {\n    this.toggle();\n  }\n  /**\n   * Handles click events on the trigger button.\n   * Note: Pointer events are typically handled by the interaction controller;\n   * this method is called when `this.button.click()` is invoked programmatically.\n   */\n  handleButtonClick() {\n    if (this.disabled) {\n      return;\n    }\n    this.toggle();\n  }\n  /**\n   * Handles blur events on the trigger button, removing focus styling.\n   */\n  handleButtonBlur() {\n    this.focused = false;\n  }\n  /**\n   * @deprecated Use `focus()` instead.\n   * Focuses the picker button and applies focus styling.\n   */\n  handleHelperFocus() {\n    this.focused = true;\n    this.button.focus();\n  }\n  /**\n   * Handles focus events on the picker, applying visible focus styling\n   * only when focus is visible in the tree.\n   */\n  handleFocus() {\n    if (!this.disabled && this.focusElement) {\n      this.focused = this.hasVisibleFocusInTree();\n    }\n  }\n  /**\n   * Handles change events from the menu, updating the selected value.\n   * Dispatches a `change` event that can be prevented to cancel the selection.\n   *\n   * @param event - The change event from the menu\n   */\n  handleChange(event) {\n    if (this.strategy) {\n      this.strategy.preventNextToggle = \"no\";\n    }\n    const target = event.target;\n    const [selected] = target.selectedItems;\n    event.stopPropagation();\n    if (event.cancelable) {\n      this.setValueFromItem(selected, event);\n    } else {\n      this.open = false;\n      if (this.strategy) {\n        this.strategy.open = false;\n      }\n    }\n  }\n  /**\n   * Handles focus events on the trigger button, delegating to the interaction strategy.\n   *\n   * @param event - The focus event\n   */\n  handleButtonFocus(event) {\n    var _a;\n    (_a = this.strategy) == null ? void 0 : _a.handleButtonFocus(event);\n  }\n  /**\n   * Opens the picker via keyboard interaction and focuses the first selected item.\n   * If already open, focuses the first selected item in the menu.\n   */\n  async keyboardOpen() {\n    var _a;\n    if (!this.open || !this.strategy.open) {\n      this.addEventListener(\n        \"sp-opened\",\n        () => {\n          var _a2;\n          return (_a2 = this.optionsMenu) == null ? void 0 : _a2.focusOnFirstSelectedItem();\n        },\n        {\n          once: true\n        }\n      );\n      this.toggle(true);\n    } else {\n      (_a = this.optionsMenu) == null ? void 0 : _a.focusOnFirstSelectedItem();\n    }\n  }\n  /**\n   * Sets the picker's value from a menu item selection.\n   * Dispatches a cancelable `change` event and reverts the selection if prevented.\n   *\n   * @param item - The menu item to select\n   * @param menuChangeEvent - The original menu change event, if any\n   */\n  async setValueFromItem(item, menuChangeEvent) {\n    var _a;\n    this.open = false;\n    const oldSelectedItem = this.selectedItem;\n    const oldValue = this.value;\n    this.selectedItem = item;\n    this.value = (_a = item == null ? void 0 : item.value) != null ? _a : \"\";\n    await this.updateComplete;\n    const applyDefault = this.dispatchEvent(\n      new Event(\"change\", {\n        bubbles: true,\n        // Allow it to be prevented.\n        cancelable: true,\n        composed: true\n      })\n    );\n    if (!applyDefault && this.selects) {\n      if (menuChangeEvent) {\n        menuChangeEvent.preventDefault();\n      }\n      this.setMenuItemSelected(this.selectedItem, false);\n      if (oldSelectedItem) {\n        this.setMenuItemSelected(oldSelectedItem, true);\n      }\n      this.selectedItem = oldSelectedItem;\n      this.value = oldValue;\n      this.open = true;\n      if (this.strategy) {\n        this.strategy.open = true;\n      }\n      return;\n    } else if (!this.selects) {\n      this.selectedItem = oldSelectedItem;\n      this.value = oldValue;\n      return;\n    }\n    if (oldSelectedItem) {\n      this.setMenuItemSelected(oldSelectedItem, false);\n    }\n    this.setMenuItemSelected(item, !!this.selects);\n  }\n  /**\n   * Updates the selected state of a menu item.\n   *\n   * @param item - The menu item to update\n   * @param value - Whether the item should be selected\n   */\n  setMenuItemSelected(item, value) {\n    if (this.selects == null) {\n      return;\n    }\n    item.selected = value;\n  }\n  /**\n   * Returns inline styles for the overlay container.\n   * On mobile, sets full width; on desktop, returns empty styles.\n   */\n  get containerStyles() {\n    if (this.isMobile.matches) {\n      return {\n        \"--swc-menu-width\": \"100%\"\n      };\n    }\n    return {};\n  }\n  get selectedItemContent() {\n    return this._selectedItemContent || { icon: [], content: [] };\n  }\n  set selectedItemContent(selectedItemContent) {\n    if (selectedItemContent === this.selectedItemContent) {\n      return;\n    }\n    const oldContent = this.selectedItemContent;\n    this._selectedItemContent = selectedItemContent;\n    this.requestUpdate(\"selectedItemContent\", oldContent);\n  }\n  /**\n   * Handles slotchange events for the tooltip slot.\n   * Sets up the trigger element for self-managed tooltips.\n   *\n   * @param event - The slotchange event\n   */\n  handleTooltipSlotchange(event) {\n    var _a;\n    this.tooltipEl = event.target.assignedElements()[0];\n    if ((_a = this.tooltipEl) == null ? void 0 : _a.selfManaged) {\n      this.updateComplete.then(() => {\n        var _a2;\n        if (((_a2 = this.tooltipEl) == null ? void 0 : _a2.overlayElement) && this.button) {\n          this.tooltipEl.overlayElement.triggerElement = this.button;\n        }\n      });\n    }\n  }\n  /**\n   * Renders the label content for the picker button.\n   * Shows the selected item's content if available, otherwise renders the placeholder label.\n   *\n   * @param content - The content nodes from the selected item\n   * @returns The rendered label content\n   */\n  renderLabelContent(content) {\n    if (this.value && this.selectedItem) {\n      return content;\n    }\n    return html`\n      <slot name=\"label\" id=\"label\">\n        <span aria-hidden=${ifDefined(this.appliedLabel ? void 0 : \"true\")}>\n          ${this.label}\n        </span>\n      </slot>\n    `;\n  }\n  /**\n   * Renders the loading indicator shown during pending state.\n   * Dynamically imports the progress-circle component.\n   *\n   * @returns The rendered progress circle template\n   */\n  renderLoader() {\n    import(\"@spectrum-web-components/progress-circle/sp-progress-circle.js\");\n    return html`\n      <sp-progress-circle\n        size=\"s\"\n        indeterminate\n        role=\"presentation\"\n        class=\"progress-circle\"\n      ></sp-progress-circle>\n    `;\n  }\n  /**\n   * Returns the content to render inside the action button.\n   * Includes the icon slot (with \"more\" icon default), label slot, and label-only slot.\n   */\n  get buttonContent() {\n    return [\n      html`\n        ${this.labelOnly ? nothing : html`\n              <slot\n                name=\"icon\"\n                slot=\"icon\"\n                ?icon-only=${!this.hasLabel}\n                ?hidden=${this.labelOnly}\n              >\n                <sp-icon-more class=\"icon\" size=${this.size}></sp-icon-more>\n              </slot>\n            `}\n        <slot name=\"label\" ?hidden=${!this.hasLabel}></slot>\n        <slot name=\"label-only\"></slot>\n      `\n    ];\n  }\n  /**\n   * Checks whether the action menu has an accessible label through any supported method:\n   * Extends base check to include label slot content and label-only slot.\n   * - `label` attribute\n   * - `aria-label` attribute\n   * - `aria-labelledby` attribute\n   * - Applied label from a field label\n   * - Slotted label content\n   *\n   * @returns True if an accessible label is present\n   */\n  hasAccessibleLabel() {\n    return !!this.label || !!this.getAttribute(\"aria-label\") || !!this.getAttribute(\"aria-labelledby\") || !!this.appliedLabel || this.hasLabel || this.labelOnly;\n  }\n  /**\n   * Logs a warning in debug mode when the action menu lacks an accessible label.\n   * Provides guidance specific to action menu labeling options.\n   */\n  warnNoLabel() {\n    if (true) {\n      window.__swc.warn(\n        this,\n        `<${this.localName}> needs one of the following to be accessible:`,\n        \"https://opensource.adobe.com/spectrum-web-components/components/action-menu/#accessibility\",\n        {\n          type: \"accessibility\",\n          issues: [\n            `an <sp-field-label> element with a \\`for\\` attribute referencing the \\`id\\` of the \\`<${this.localName}>\\`, or`,\n            'value supplied to the \"label\" attribute, which will be displayed visually as placeholder text',\n            'text content supplied in a <span> with slot=\"label\", or, text content supplied in a <span> with slot=\"label-only\"',\n            \"which will also be displayed visually as placeholder text.\"\n          ]\n        }\n      );\n    }\n  }\n  /**\n   * Renders the overlay element containing the menu.\n   * Configures the overlay with appropriate placement, type, and event handlers.\n   *\n   * @param menu - The menu template to render inside the overlay\n   * @returns The rendered overlay template\n   */\n  renderOverlay(menu) {\n    var _a;\n    const container = this.renderContainer(menu);\n    this.dependencyManager.add(\"sp-overlay\");\n    import(\"@spectrum-web-components/overlay/sp-overlay.js\");\n    return html`\n      <sp-overlay\n        @slottable-request=${this.handleSlottableRequest}\n        @beforetoggle=${this.handleBeforetoggle}\n        .triggerElement=${this}\n        .offset=${0}\n        ?open=${this.open && this.dependencyManager.loaded}\n        .placement=${this.isMobile.matches && !this.forcePopover ? void 0 : this.placement}\n        .type=${this.isMobile.matches && !this.forcePopover ? \"modal\" : \"auto\"}\n        .receivesFocus=${\"false\"}\n        .willPreventClose=${((_a = this.strategy) == null ? void 0 : _a.preventNextToggle) !== \"no\" && this.open && this.dependencyManager.loaded}\n      >\n        ${container}\n      </sp-overlay>\n    `;\n  }\n  /**\n   * Renders the description slot for additional picker context.\n   * Content is referenced by aria-describedby for accessibility.\n   */\n  get renderDescriptionSlot() {\n    return html`\n      <div id=${DESCRIPTION_ID}>\n        <slot name=\"description\"></slot>\n      </div>\n    `;\n  }\n  /**\n   * Renders the action menu component.\n   * Uses an action button as the trigger instead of a standard button.\n   */\n  render() {\n    if (this.tooltipEl) {\n      this.tooltipEl.disabled = this.open;\n    }\n    return html`\n      <sp-action-button\n        aria-describedby=${DESCRIPTION_ID}\n        ?quiet=${this.quiet}\n        ?selected=${this.open}\n        static-color=${ifDefined(this.staticColor)}\n        aria-haspopup=\"true\"\n        aria-controls=${ifDefined(this.open ? \"menu\" : void 0)}\n        aria-expanded=${this.open ? \"true\" : \"false\"}\n        aria-label=${ifDefined(this.label || void 0)}\n        id=\"button\"\n        class=\"button\"\n        size=${this.size}\n        @blur=${this.handleButtonBlur}\n        @focus=${this.handleButtonFocus}\n        @keydown=${{\n      handleEvent: this.handleEnterKeydown,\n      capture: true\n    }}\n        ?disabled=${this.disabled}\n      >\n        ${this.buttonContent}\n      </sp-action-button>\n      <slot name=\"tooltip\" @slotchange=${this.handleTooltipSlotchange}></slot>\n      ${this.renderMenu} ${this.renderDescriptionSlot}\n    `;\n  }\n  /**\n   * Lifecycle callback before the component updates.\n   * Transfers tabIndex from the host element to the internal button.\n   *\n   * @param changedProperties - Map of changed property names to previous values\n   */\n  willUpdate(changedProperties) {\n    super.willUpdate(changedProperties);\n    if (changedProperties.has(\"tabIndex\") && !!this.tabIndex) {\n      this.button.tabIndex = this.tabIndex;\n      this.removeAttribute(\"tabindex\");\n    }\n  }\n  /**\n   * Handles property updates.\n   * Forces the invalid property to always be false since action menus\n   * don't support validation states.\n   *\n   * @param changedProperties - Map of changed property names to previous values\n   */\n  update(changedProperties) {\n    var _a, _b;\n    if (changedProperties.has(\"invalid\")) {\n      this.invalid = false;\n    }\n    if (this.selects) {\n      this.selects = \"single\";\n    }\n    if (changedProperties.has(\"disabled\") && this.disabled) {\n      this.close();\n    }\n    if (changedProperties.has(\"pending\") && this.pending) {\n      this.close();\n    }\n    if (changedProperties.has(\"value\")) {\n      this.shouldScheduleManageSelection();\n    }\n    if (!this.hasUpdated) {\n      this.deprecatedMenu = this.querySelector(\":scope > sp-menu\");\n      (_a = this.deprecatedMenu) == null ? void 0 : _a.toggleAttribute(\"ignore\", true);\n      (_b = this.deprecatedMenu) == null ? void 0 : _b.setAttribute(\"selects\", \"inherit\");\n    }\n    if (true) {\n      if (!this.hasUpdated && this.querySelector(\":scope > sp-menu\")) {\n        const { localName } = this;\n        window.__swc.warn(\n          this,\n          `You no longer need to provide an <sp-menu> child to ${localName}. Any styling or attributes on the <sp-menu> will be ignored.`,\n          \"https://opensource.adobe.com/spectrum-web-components/components/picker/#sizes\",\n          { level: \"deprecation\" }\n        );\n      }\n      this.updateComplete.then(async () => {\n        await new Promise((res) => requestAnimationFrame(res));\n        await new Promise((res) => requestAnimationFrame(res));\n        if (!this.hasAccessibleLabel()) {\n          this.warnNoLabel();\n        }\n      });\n    }\n    super.update(changedProperties);\n  }\n  /**\n   * Binds the keydown event listener to the trigger button.\n   * Called during first update to enable keyboard navigation.\n   */\n  bindButtonKeydownListener() {\n    this.button.addEventListener(\"keydown\", this.handleKeydown);\n  }\n  /**\n   * Lifecycle callback after the component has updated.\n   * Ensures the strategy has a reference to the overlay element when opened.\n   *\n   * @param changedProperties - Map of changed property names to previous values\n   */\n  updated(changedProperties) {\n    super.updated(changedProperties);\n    if (changedProperties.has(\"open\") && this.overlayElement && !this.strategy.overlay) {\n      this.strategy.overlay = this.overlayElement;\n    }\n  }\n  /**\n   * Lifecycle callback after the component's first update.\n   * Binds keyboard listeners and initializes the interaction strategy.\n   *\n   * @param changedProperties - Map of changed property names to previous values\n   */\n  async firstUpdated(changedProperties) {\n    super.firstUpdated(changedProperties);\n    this.bindButtonKeydownListener();\n    this.bindEvents();\n    await this.updateComplete;\n    if (this.overlayElement && !this.strategy.overlay) {\n      this.strategy.overlay = this.overlayElement;\n    }\n  }\n  /**\n   * Renders a visually hidden dismiss button for accessibility.\n   * Allows screen reader users to dismiss the overlay.\n   */\n  get dismissHelper() {\n    return html`\n      <div class=\"visually-hidden\">\n        <button\n          tabindex=\"-1\"\n          aria-label=\"Dismiss\"\n          @click=${this.close}\n        ></button>\n      </div>\n    `;\n  }\n  /**\n   * Renders the overlay container (popover or tray) based on device type.\n   * On mobile, uses a tray; on desktop, uses a popover.\n   *\n   * @param menu - The menu template to wrap in the container\n   * @returns The rendered container template\n   */\n  renderContainer(menu) {\n    const accessibleMenu = html`\n      ${this.dismissHelper} ${menu} ${this.dismissHelper}\n    `;\n    if (this.isMobile.matches && !this.forcePopover) {\n      this.dependencyManager.add(\"sp-tray\");\n      import(\"@spectrum-web-components/tray/sp-tray.js\");\n      return html`\n        <sp-tray\n          id=\"popover\"\n          role=\"presentation\"\n          style=${styleMap(this.containerStyles)}\n        >\n          ${accessibleMenu}\n        </sp-tray>\n      `;\n    }\n    this.dependencyManager.add(\"sp-popover\");\n    import(\"@spectrum-web-components/popover/sp-popover.js\");\n    return html`\n      <sp-popover\n        id=\"popover\"\n        role=\"presentation\"\n        style=${styleMap(this.containerStyles)}\n        placement=${this.placement}\n      >\n        ${accessibleMenu}\n      </sp-popover>\n    `;\n  }\n  /**\n   * Dispatches a scroll event when the menu is scrolled.\n   * Allows parent components to react to menu scroll events.\n   */\n  onScroll() {\n    this.dispatchEvent(\n      new Event(\"scroll\", {\n        cancelable: true,\n        composed: true\n      })\n    );\n  }\n  /**\n   * Renders the menu and overlay structure.\n   * Lazily renders the overlay only after the picker has been focused or opened.\n   */\n  get renderMenu() {\n    const menu = html`\n      <sp-menu\n        aria-labelledby=\"applied-label\"\n        @change=${this.handleChange}\n        id=\"menu\"\n        @keydown=${{\n      handleEvent: this.handleEnterKeydown,\n      capture: true\n    }}\n        @scroll=${this.onScroll}\n        role=${this.listRole}\n        .selects=${this.selects}\n        .selected=${this.value ? [this.value] : []}\n        .shouldSupportDragAndSelect=${!this.isTouchDevice.matches}\n        size=${this.size}\n        @sp-menu-item-keydown=${this.handleEscape}\n        @sp-menu-item-added-or-updated=${this.shouldManageSelection}\n      >\n        <slot @slotchange=${this.shouldScheduleManageSelection}></slot>\n      </sp-menu>\n    `;\n    this.hasRenderedOverlay = this.hasRenderedOverlay || this.focused || this.open || !!this.deprecatedMenu;\n    if (this.hasRenderedOverlay) {\n      if (this.dependencyManager.loaded) {\n        this.dependencyManager.add(\"sp-overlay\");\n      }\n      return this.renderOverlay(menu);\n    }\n    return menu;\n  }\n  /**\n   * Schedules selection management for the next animation frame.\n   * Called when the value changes or menu slot content changes.\n   * Prevents duplicate scheduling if already pending.\n   *\n   * @param event - Optional event that triggered the scheduling\n   */\n  shouldScheduleManageSelection(event) {\n    if (!this.willManageSelection && (!event || event.target.getRootNode().host === this)) {\n      this.willManageSelection = true;\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          this.manageSelection();\n        });\n      });\n    }\n  }\n  /**\n   * Immediately manages selection when a menu item is added or updated.\n   * Skips if selection management is already scheduled.\n   */\n  shouldManageSelection() {\n    if (this.willManageSelection) {\n      return;\n    }\n    this.willManageSelection = true;\n    this.manageSelection();\n  }\n  /**\n   * Synchronizes the menu selection state with the picker's current value.\n   * Finds and selects the menu item matching the current value,\n   * and deselects all other items.\n   */\n  async manageSelection() {\n    if (this.selects == null) {\n      return;\n    }\n    this.selectionPromise = new Promise(\n      (res) => this.selectionResolver = res\n    );\n    let selectedItem;\n    await this.optionsMenu.updateComplete;\n    if (this.recentlyConnected) {\n      await new Promise((res) => requestAnimationFrame(() => res(true)));\n      this.recentlyConnected = false;\n    }\n    this.menuItems.forEach((item) => {\n      if (this.value === item.value && !item.disabled) {\n        selectedItem = item;\n      } else {\n        item.selected = false;\n      }\n    });\n    if (selectedItem) {\n      selectedItem.selected = !!this.selects;\n      this.selectedItem = selectedItem;\n    } else {\n      const hasItemsWithValues = this.menuItems.some(\n        (item) => {\n          var _a;\n          return item.value != null || ((_a = item.getAttribute) == null ? void 0 : _a.call(item, \"value\")) != null;\n        }\n      );\n      if (this.menuItems.length > 0 && hasItemsWithValues) {\n        this.value = \"\";\n        this.selectedItem = void 0;\n      }\n    }\n    if (this.open) {\n      await this.optionsMenu.updateComplete;\n      this.optionsMenu.updateSelectedItemIndex();\n    }\n    this.selectionResolver();\n    this.willManageSelection = false;\n  }\n  /**\n   * Returns a promise that resolves when the component update is complete,\n   * including any pending selection management.\n   */\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    await this.selectionPromise;\n    return complete;\n  }\n  /**\n   * Lifecycle callback when the element is connected to the DOM.\n   * Sets up tooltip trigger elements and focus event listeners.\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.updateComplete.then(() => {\n      var _a;\n      if (!((_a = this.tooltipEl) == null ? void 0 : _a.selfManaged)) {\n        return;\n      }\n      const overlayElement = this.tooltipEl.overlayElement;\n      if (overlayElement) {\n        overlayElement.triggerElement = this.button;\n      }\n    });\n    this.recentlyConnected = this.hasUpdated;\n    this.addEventListener(\"focus\", this.handleFocus);\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener(\"focus\", this.handleFocus);\n  }\n  /**\n   * Sets the currently selected menu item and updates the displayed content.\n   *\n   * @param selectedItem - The menu item to select, or undefined to clear selection\n   */\n  set selectedItem(selectedItem) {\n    this.selectedItemContent = selectedItem ? selectedItem.itemChildren : void 0;\n    if (selectedItem === this.selectedItem) {\n      return;\n    }\n    const oldSelectedItem = this.selectedItem;\n    this._selectedItem = selectedItem;\n    this.requestUpdate(\"selectedItem\", oldSelectedItem);\n  }\n  /**\n   * Whether the label slot has content.\n   * Used to determine button layout and icon visibility.\n   */\n  get hasLabel() {\n    return this.slotHasContent;\n  }\n  get labelOnly() {\n    return this.slotContentIsPresent;\n  }\n}\n__decorateClass([\n  property({ type: String })\n], ActionMenu.prototype, \"selects\", 2);\n__decorateClass([\n  state()\n], ActionMenu.prototype, \"labelAlignment\", 2);\n__decorateClass([\n  state()\n], ActionMenu.prototype, \"appliedLabel\", 2);\n__decorateClass([\n  property({ type: String, reflect: true })\n], ActionMenu.prototype, \"icons\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ActionMenu.prototype, \"invalid\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"pending-label\" })\n], ActionMenu.prototype, \"pendingLabel\", 2);\n__decorateClass([\n  property()\n], ActionMenu.prototype, \"label\", 2);\n__decorateClass([\n  property({ reflect: true, attribute: \"static-color\" })\n], ActionMenu.prototype, \"staticColor\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ActionMenu.prototype, \"quiet\", 2);\n__decorateClass([\n  property({ type: String })\n], ActionMenu.prototype, \"value\", 2);\n__decorateClass([\n  property({ attribute: false })\n], ActionMenu.prototype, \"selectedItem\", 1);\n__decorateClass([\n  state()\n], ActionMenu.prototype, \"selectedItemContent\", 1);\n__decorateClass([\n  state()\n], ActionMenu.prototype, \"labelOnly\", 1);\n//# sourceMappingURL=ActionMenu.dev.js.map\n","\"use strict\";import{tag as t}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const MoreIcon=({width:r=24,height:l=24,hidden:e=!1,title:c=\"More\"}={})=>t`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${r}\"\n    height=\"${l}\"\n    viewBox=\"0 0 20 20\"\n    aria-hidden=${e?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${c}\"\n  >\n    <circle cx=\"10\" cy=\"10.02114\" r=\"1.5\" fill=\"currentColor\" />\n    <path\n      d=\"m10,8.5c-.82843,0-1.5.67157-1.5,1.5s.67157,1.5,1.5,1.5,1.5-.67157,1.5-1.5-.67157-1.5-1.5-1.5Z\"\n      fill=\"currentColor\"\n    />\n    <circle cx=\"4\" cy=\"10.02114\" r=\"1.5\" fill=\"currentColor\" />\n    <circle cx=\"4\" cy=\"10\" r=\"1.5\" fill=\"currentColor\" />\n    <circle cx=\"16\" cy=\"10.02114\" r=\"1.5\" fill=\"currentColor\" />\n    <circle cx=\"16\" cy=\"10\" r=\"1.5\" fill=\"currentColor\" />\n  </svg>`;\n//# sourceMappingURL=More.js.map\n","\"use strict\";import{html as e}from\"@spectrum-web-components/base\";import{IconBase as t}from\"@spectrum-web-components/icon\";import{setCustomTemplateLiteralTag as r}from\"../custom-tag.js\";import{MoreIcon as o}from\"../icons-s2/More.js\";import{MoreIcon as l}from\"../icons/More.js\";export class IconMore extends t{render(){return r(e),this.spectrumVersion===2?o({hidden:!this.label,title:this.label}):l({hidden:!this.label,title:this.label})}}\n//# sourceMappingURL=IconMore.js.map\n","\"use strict\";import{tag as c}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const MoreIcon=({width:e=24,height:r=24,hidden:t=!1,title:l=\"More\"}={})=>c`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${e}\"\n    height=\"${r}\"\n    viewBox=\"0 0 36 36\"\n    aria-hidden=${t?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${l}\"\n  >\n    <circle cx=\"17.8\" cy=\"18.2\" r=\"3.4\" />\n    <circle cx=\"29.5\" cy=\"18.2\" r=\"3.4\" />\n    <circle cx=\"6.1\" cy=\"18.2\" r=\"3.4\" />\n  </svg>`;\n//# sourceMappingURL=More.js.map\n"],"names":[],"sourceRoot":""}