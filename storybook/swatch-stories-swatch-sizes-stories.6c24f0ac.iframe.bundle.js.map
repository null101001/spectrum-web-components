{"version":3,"file":"swatch-stories-swatch-sizes-stories.6c24f0ac.iframe.bundle.js","mappings":";;AACA;;AAqMA;AACA;;AAGA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;;AAKA","sources":["webpack://@spectrum-web-components/1st-gen/./packages/swatch/src/SwatchGroup.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/swatch/stories/swatch-sizes.stories.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SizedMixin,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  queryAssignedElements\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { RovingTabindexController } from \"@spectrum-web-components/reactive-controllers/src/RovingTabindex.js\";\nimport { MutationController } from \"@lit-labs/observers/mutation-controller.js\";\nimport styles from \"./swatch-group.css.js\";\nexport class SwatchGroup extends SizedMixin(SpectrumElement, {\n  validSizes: [\"xs\", \"s\", \"m\", \"l\"],\n  noDefaultSize: true\n}) {\n  constructor() {\n    super();\n    // Specifically surface `_selected` internally so that change can be made to this value internally\n    // without triggering the update lifecycle directly.\n    this._selected = [];\n    this.selectedSet = /* @__PURE__ */ new Set();\n    this.rovingTabindexController = new RovingTabindexController(this, {\n      focusInIndex: (elements) => {\n        let firstEnabledIndex = -1;\n        const firstSelectedIndex = elements.findIndex((el, index) => {\n          if (!elements[firstEnabledIndex] && !el.disabled) {\n            firstEnabledIndex = index;\n          }\n          return el.selected && !el.disabled;\n        });\n        return elements[firstSelectedIndex] ? firstSelectedIndex : firstEnabledIndex;\n      },\n      elements: () => this.swatches,\n      isFocusableElement: (el) => !el.disabled\n    });\n    this.manageChange = async () => {\n      const presentSet = /* @__PURE__ */ new Set();\n      this.selectedSet = new Set(this.selected);\n      await Promise.all(this.swatches.map((swatch) => swatch.updateComplete));\n      this.swatches.forEach((swatch) => {\n        presentSet.add(swatch.value);\n        if (swatch.selected) {\n          this.selectedSet.add(swatch.value);\n        }\n      });\n      this.selectedSet.forEach((value) => {\n        if (!presentSet.has(value)) {\n          this.selectedSet.delete(value);\n        }\n      });\n      this._selected = [...this.selectedSet];\n      this.rovingTabindexController.clearElementCache();\n    };\n    new MutationController(this, {\n      config: {\n        attributes: true,\n        childList: true,\n        subtree: true\n      },\n      callback: () => {\n        this.manageChange();\n      }\n    });\n  }\n  static get styles() {\n    return [styles];\n  }\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected) {\n    if (selected === this.selected) return;\n    const oldSelected = this.selected;\n    this._selected = selected;\n    this.requestUpdate(\"selected\", oldSelected);\n  }\n  focus(options) {\n    this.rovingTabindexController.focus(options);\n  }\n  handleChange(event) {\n    event.stopPropagation();\n    const oldSelected = this.selected;\n    if (!this.selects) {\n      event.preventDefault();\n      return;\n    }\n    if (this.selects === \"single\") {\n      const { target } = event;\n      target.tabIndex = 0;\n      target.selected = true;\n      if (this.selectedSet.has(target.value)) {\n        return;\n      }\n      this.selectedSet.clear();\n      this.selectedSet.add(target.value);\n      this.rovingTabindexController.elements.forEach((child) => {\n        if (child === target) return;\n        child.selected = false;\n      });\n    } else if (this.selects === \"multiple\") {\n      const { target } = event;\n      if (target.selected) {\n        this.selectedSet.add(target.value);\n      } else {\n        this.selectedSet.delete(target.value);\n      }\n    }\n    this._selected = [...this.selectedSet];\n    const applyDefault = this.dispatchEvent(\n      new Event(\"change\", {\n        cancelable: true,\n        bubbles: true\n      })\n    );\n    if (!applyDefault) {\n      this._selected = oldSelected;\n      event.preventDefault();\n    }\n  }\n  getPassthroughSwatchActions(changes) {\n    const targetValues = {};\n    if (changes.has(\"selects\") && (this.selects || typeof changes.get(\"selects\") !== \"undefined\")) {\n      targetValues.selects = this.selects;\n    }\n    if (changes.has(\"border\") && (this.border || typeof changes.get(\"border\") !== \"undefined\")) {\n      targetValues.border = this.border;\n    }\n    if (changes.has(\"rounding\") && (this.rounding || typeof changes.get(\"rounding\") !== \"undefined\")) {\n      targetValues.rounding = this.rounding;\n    }\n    if (changes.has(\"size\") && (this.size !== \"m\" || typeof changes.get(\"size\") !== \"undefined\")) {\n      targetValues.size = this.size;\n    }\n    if (changes.has(\"shape\") && (this.shape || typeof changes.get(\"shape\") !== \"undefined\")) {\n      targetValues.shape = this.shape;\n    }\n    const passThroughSwatchActions = [];\n    if (Object.keys(targetValues).length) {\n      passThroughSwatchActions.push((swatch) => {\n        if (true) {\n          if (\"selects\" in targetValues && targetValues.selects !== \"multiple\" && swatch.mixedValue) {\n            window.__swc.warn(\n              this,\n              `<sp-swatch> elements can only leverage the \"mixed-value\" attribute when their <sp-swatch-group> parent element is also leveraging \"selects=\"multiple\"\"`,\n              \"https://opensource.adobe.com/spectrum-web-components/components/swatch-group/#multiple\",\n              {\n                type: \"accessibility\"\n              }\n            );\n          }\n        }\n        if (\"border\" in targetValues)\n          swatch.border = targetValues.border;\n        if (\"rounding\" in targetValues)\n          swatch.rounding = targetValues.rounding;\n        if (\"shape\" in targetValues) swatch.shape = targetValues.shape;\n        if (\"size\" in targetValues)\n          swatch.size = targetValues.size;\n      });\n    }\n    return passThroughSwatchActions;\n  }\n  getSelectionSwatchActions(changes) {\n    const selectionSwatchActions = [];\n    if (!changes.has(\"selects\")) return selectionSwatchActions;\n    if (this.selects) {\n      this.setAttribute(\n        \"role\",\n        this.selects === \"single\" ? \"radiogroup\" : \"group\"\n      );\n    } else {\n      this.removeAttribute(\"role\");\n    }\n    const swatchRoles = {\n      single: \"radio\",\n      multiple: \"checkbox\"\n    };\n    const swatchRole = this.selects ? swatchRoles[this.selects] : \"button\";\n    selectionSwatchActions.push((swatch) => {\n      swatch.setAttribute(\"role\", swatchRole);\n    });\n    return selectionSwatchActions;\n  }\n  render() {\n    return html`\n            <slot\n                @change=${this.handleChange}\n                @slotchange=${this.manageChange}\n            ></slot>\n        `;\n  }\n  willUpdate(changes) {\n    const swatchActions = [\n      ...this.getPassthroughSwatchActions(changes),\n      ...this.getSelectionSwatchActions(changes)\n    ];\n    let nextSelected = new Set(this.selected);\n    const currentValues = /* @__PURE__ */ new Set();\n    if (changes.has(\"selected\")) {\n      swatchActions.push((swatch) => {\n        currentValues.add(swatch.value);\n        if (nextSelected.has(swatch.value) || !this.hasUpdated && swatch.selected) {\n          swatch.selected = true;\n        } else {\n          swatch.selected = false;\n        }\n      });\n    }\n    const doActions = () => {\n      nextSelected = new Set(this.selected);\n      this.swatches.forEach((swatch) => {\n        swatchActions.forEach((action) => {\n          action(swatch);\n        });\n      });\n      if (changes.has(\"selected\")) {\n        this._selected = [...nextSelected.values()].filter(\n          (selectedValue) => currentValues.has(selectedValue)\n        );\n      }\n    };\n    if (this.hasUpdated) {\n      doActions();\n    } else {\n      this.shadowRoot.addEventListener(\n        \"slotchange\",\n        () => {\n          requestAnimationFrame(doActions);\n        },\n        { once: true }\n      );\n    }\n  }\n}\n__decorateClass([\n  property({ reflect: true })\n], SwatchGroup.prototype, \"border\", 2);\n__decorateClass([\n  property({ reflect: true })\n], SwatchGroup.prototype, \"density\", 2);\n__decorateClass([\n  property({ reflect: true })\n], SwatchGroup.prototype, \"rounding\", 2);\n__decorateClass([\n  property({ type: Array })\n], SwatchGroup.prototype, \"selected\", 1);\n__decorateClass([\n  property()\n], SwatchGroup.prototype, \"selects\", 2);\n__decorateClass([\n  property({ reflect: true })\n], SwatchGroup.prototype, \"shape\", 2);\n__decorateClass([\n  queryAssignedElements({ flatten: true })\n], SwatchGroup.prototype, \"swatches\", 2);\n//# sourceMappingURL=SwatchGroup.dev.js.map\n","\"use strict\";\nimport {\n  html\n} from \"@spectrum-web-components/base\";\nimport \"@spectrum-web-components/swatch/sp-swatch.js\";\nimport \"@spectrum-web-components/swatch/sp-swatch-group.js\";\nexport default {\n  title: \"Swatch/Sizes\",\n  component: \"sp-swatch\"\n};\nconst template = ({\n  size,\n  color = \"rgb(255 0 0 / 0.7)\"\n}) => html`\n    <sp-swatch-group selects=\"multiple\">\n        <sp-swatch color=${color} size=${size}></sp-swatch>\n        <sp-swatch color=${color} rounding=\"none\" size=${size}></sp-swatch>\n        <sp-swatch color=${color} rounding=\"full\" size=${size}></sp-swatch>\n        <sp-swatch color=${color} border=\"light\" size=${size}></sp-swatch>\n        <sp-swatch color=${color} border=\"none\" size=${size}></sp-swatch>\n        <sp-swatch nothing size=${size}></sp-swatch>\n        <sp-swatch color=${color} shape=\"rectangle\" size=${size}></sp-swatch>\n        <sp-swatch\n            color=${color}\n            shape=\"rectangle\"\n            size=${size}\n            disabled\n        ></sp-swatch>\n        <sp-swatch\n            rounding=\"full\"\n            shape=\"rectangle\"\n            size=${size}\n            mixed-value\n        ></sp-swatch>\n    </sp-swatch-group>\n`;\nexport const XS = () => template({ size: \"xs\" });\nexport const s = () => template({ size: \"s\" });\nexport const m = () => template({ size: \"m\" });\nexport const l = () => template({ size: \"l\" });\n//# sourceMappingURL=swatch-sizes.stories.js.map\n;export const __namedExportsOrder = [\"XS\",\"s\",\"m\",\"l\"];"],"names":[],"sourceRoot":""}