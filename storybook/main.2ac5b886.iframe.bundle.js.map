{"version":3,"file":"main.2ac5b886.iframe.bundle.js","mappings":";;;AA+CA;;AAEA;AACA;AACA;;AAGA;;;;ACrDA;;;AA+GA;;;;AAIA;;AAGA;;AC1DA;;AAGA;AACA;AACA;;AAIA;;ACrEA;;AA6DA;;AC5DA;;ACAA;;;ACCA;;;AAGA;AACA;AACA;;;;;ACRA;;;ACGA;;;AAGA;AACA;AACA;;;;;ACRA;;;ACGA;;;AAGA;AACA;AACA;;;;;ACRA;;;ACGA;;;AAGA;AACA;AACA;;;;;;;;ACLA;;;AAGA;AACA;AACA;;;;;;;;ACLA;;;AAGA;AACA;AACA;;;;;;;ACNA;AACA;;AAEA;;;AAGA;;;;;;;;;;;;;;;;ACNA;;AAEA;AACA;;;AAGA;;;;;;;ACPA;;;AA2SA;AACA;AAMA;;AAGA;;;AAUA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AAIA;AACA;AACA;;AAEA;;;;;;AA5BA;AAsCA;;;;;;AAMA;;AAEA;;;;;;;AAOA;AAKA;AAEA;;AClXA;;AA+vBA;AACA;AACA;;AAGA;;ACpwBA;;ACmiBA;AACA;;;AAIA;;;;;;;AAgBA;AAcA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;AAMA;;AAEA;;AAEA;;AAIA;;AAkDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AAOA;;;AAIA;;AASA;AACA;AACA;;;;AAIA;AAGA;AACA;AACA;AAIA;;AAEA;;;;;;AAMA;AACA;;AAEA;AAEA;;;;;AA+EA;;;AAIA;AASA;AAEA;;;;AAOA;;AAEA;;AAIA;;;;AAMA;AACA;;AAEA;;AAGA;;;AAqBA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;;AAsgBA;AACA;;;AAIA;;;;;;;AAgBA;AAcA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;AAMA;;AAEA;;AAEA;;AAIA;;AAkDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AAOA;;;AAIA;;AASA;AACA;AACA;;;;AAIA;AAGA;AACA;AACA;AAIA;;AAEA;;;;;;AAMA;AACA;;AAEA;AAEA;;;;;AA+EA;;;AAIA;AASA;AAEA;;;;AAOA;;AAEA;;AAIA;;;;AAMA;AACA;;AAEA;;AAGA;;;AAqBA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;;ACxtDA;;ACDA;AA+BA;;;AAIA;;ACjCA;;ACCA;;ACAA;;ACAA;;ACAA;;ACDA;;ACCA;;ACAA;;ACAA;;ACAA;;;;;;;;;;;;;;;;;;ACmEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;AAkDA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGA;;AAgCA;AACA;;AAGA;;;;;;AAQA;AACA;;;;;;AAOA;;;;;;AAQA;AACA;;;;;AAMA;;;;;;;AASA;AACA;;;;;AAMA;;;;;;;AAYA;AACA;;AAEA;AAZA;;;AAeA;;;;;;;AASA;AACA;;;;;AAMA;;;AAKA;AACA;;;;AAKA;;;;;AAcA;;;;;;;;;;;;;;;;;ACvSA;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AC0HA;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnCA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA","sources":["webpack://@spectrum-web-components/1st-gen/./packages/checkbox/src/CheckboxMixin.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/field-label/src/FieldLabel.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/icon/src/Icon.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/icon/src/IconBase.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/icon/src/spectrum-icon-checkmark.css.js","webpack://@spectrum-web-components/1st-gen/./packages/icon/src/spectrum-icon-chevron.css.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/icons-s2/Asterisk100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/elements/IconAsterisk100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/icons-s2/Checkmark100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/elements/IconCheckmark100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/icons-s2/Chevron100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/elements/IconChevron100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/icons/Asterisk100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/icons/Checkmark100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-ui/src/icons/Chevron100.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-workflow/src/icons-s2/AlertTriangle.js","webpack://@spectrum-web-components/1st-gen/./packages/icons-workflow/src/icons/Alert.js","webpack://@spectrum-web-components/1st-gen/./packages/menu/src/MenuItem.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/menu/src/Menu.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/picker/src/InteractionController.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/picker/src/Picker.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/switch/src/switch-legacy.css.js","webpack://@spectrum-web-components/1st-gen/./packages/switch/src/Switch.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/src/spectrum-two/core.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/spectrum-two/theme-light.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/spectrum-two/theme-dark.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/spectrum-two/scale-medium.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/spectrum-two/scale-large.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/src/express/core.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/express/theme-light.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/express/theme-dark.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/express/scale-medium.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/express/scale-large.dev.js","webpack://@spectrum-web-components/1st-gen/./projects/story-decorator/src/StoryDecorator.dev.js","webpack://@spectrum-web-components/1st-gen/./projects/story-decorator/decorator.dev.js","webpack://@spectrum-web-components/1st-gen/./storybook/preview.js","webpack://@spectrum-web-components/1st-gen/./tools/shared/src/like-anchor.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/theme-light.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/theme-lightest.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/theme-dark.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/theme-darkest.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/scale-medium.dev.js","webpack://@spectrum-web-components/1st-gen/./tools/theme/scale-large.dev.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { ifDefined } from \"@spectrum-web-components/base/src/directives.js\";\nexport function CheckboxMixin(constructor) {\n  class MixedElement extends constructor {\n    constructor() {\n      super(...arguments);\n      this.checked = false;\n      this.readonly = false;\n    }\n    handleChange() {\n      if (this.readonly) {\n        this.inputElement.checked = this.checked;\n        return;\n      }\n      this.checked = this.inputElement.checked;\n      const changeEvent = new CustomEvent(\"change\", {\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n      const applyDefault = this.dispatchEvent(changeEvent);\n      if (!applyDefault) {\n        this.checked = !this.inputElement.checked;\n        this.inputElement.checked = this.checked;\n      }\n    }\n    render() {\n      return html`\n        <input\n          id=\"input\"\n          name=${ifDefined(this.name || void 0)}\n          type=\"checkbox\"\n          .checked=${this.checked}\n          ?disabled=${this.readonly}\n          @change=${this.handleChange}\n        />\n      `;\n    }\n  }\n  __decorateClass([\n    property({ type: Boolean, reflect: true })\n  ], MixedElement.prototype, \"checked\", 2);\n  __decorateClass([\n    property({ type: String, reflect: true })\n  ], MixedElement.prototype, \"name\", 2);\n  __decorateClass([\n    property({ type: Boolean, reflect: true })\n  ], MixedElement.prototype, \"readonly\", 2);\n  __decorateClass([\n    query(\"#input\")\n  ], MixedElement.prototype, \"inputElement\", 2);\n  return MixedElement;\n}\n//# sourceMappingURL=CheckboxMixin.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing,\n  SizedMixin,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  conditionAttributeWithId,\n  conditionAttributeWithoutId\n} from \"@spectrum-web-components/base/src/condition-attribute-with-id.js\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport asteriskIconStyles from \"@spectrum-web-components/icon/src/spectrum-icon-asterisk.css.js\";\nimport {\n  ElementResolutionController,\n  elementResolverUpdatedSymbol\n} from \"@spectrum-web-components/reactive-controllers/src/ElementResolution.js\";\nimport { randomID } from \"@spectrum-web-components/shared/src/random-id.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-asterisk100.js\";\nimport styles from \"./field-label.css.js\";\nexport class FieldLabel extends SizedMixin(SpectrumElement, {\n  noDefaultSize: true\n}) {\n  constructor() {\n    super(...arguments);\n    this.disabled = false;\n    this.id = \"\";\n    this.for = \"\";\n    this.required = false;\n    this.resolvedElement = new ElementResolutionController(this);\n  }\n  static get styles() {\n    return [styles, asteriskIconStyles];\n  }\n  handleClick(event) {\n    if (!this.target || this.disabled || event.defaultPrevented) {\n      return;\n    }\n    this.target.focus();\n    const parent = this.getRootNode();\n    const target = this.target;\n    const targetParent = target.getRootNode();\n    const targetHost = targetParent.host;\n    if (targetParent === parent && target.forceFocusVisible) {\n      target.forceFocusVisible();\n    } else if (targetHost && targetHost.forceFocusVisible) {\n      targetHost.forceFocusVisible();\n    }\n  }\n  applyTargetLabel(target) {\n    this.target = target || this.target;\n    if (this.target) {\n      const applyLabel = this.target.applyFocusElementLabel;\n      const focusable = this.target.focusElement || this.target;\n      const targetParent = focusable.getRootNode();\n      if (typeof applyLabel !== \"undefined\") {\n        applyLabel(this.labelText, this);\n      } else if (targetParent === this.getRootNode()) {\n        const conditionAttribute = target ? conditionAttributeWithId : conditionAttributeWithoutId;\n        conditionAttribute(focusable, \"aria-labelledby\", [this.id]);\n      } else {\n        if (target) {\n          focusable.setAttribute(\"aria-label\", this.labelText);\n        } else {\n          focusable.removeAttribute(\"aria-label\");\n        }\n      }\n    }\n  }\n  async manageTarget() {\n    this.applyTargetLabel();\n    const target = this.resolvedElement.element;\n    if (!target) {\n      this.target = target;\n      return;\n    }\n    if (target.localName.search(\"-\") > 0) {\n      await customElements.whenDefined(target.localName);\n    }\n    if (typeof target.updateComplete !== \"undefined\") {\n      await target.updateComplete;\n    }\n    this.applyTargetLabel(target);\n  }\n  get labelText() {\n    const assignedNodes = this.slotEl.assignedNodes({ flatten: true });\n    if (!assignedNodes.length) {\n      return \"\";\n    }\n    const labelText = assignedNodes.map(\n      (node) => (node.textContent || /* c8 ignore next */\n      \"\").trim()\n    );\n    return labelText.join(\" \");\n  }\n  render() {\n    return html`\n      <label>\n        <slot></slot>\n        ${this.required ? html`\n              <sp-icon-asterisk100\n                class=\"required-icon spectrum-UIIcon-Asterisk100\"\n              ></sp-icon-asterisk100>\n            ` : nothing}\n      </label>\n    `;\n  }\n  firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.addEventListener(\"click\", this.handleClick);\n  }\n  willUpdate(changes) {\n    if (!this.hasAttribute(\"id\")) {\n      this.setAttribute(\"id\", `${this.tagName.toLowerCase()}-${randomID()}`);\n    }\n    if (changes.has(\"for\")) {\n      this.resolvedElement.selector = this.for ? `#${this.for}` : \"\";\n    }\n    if (changes.has(\"id\") || changes.has(elementResolverUpdatedSymbol)) {\n      this.manageTarget();\n    }\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], FieldLabel.prototype, \"disabled\", 2);\n__decorateClass([\n  property({ type: String })\n], FieldLabel.prototype, \"id\", 2);\n__decorateClass([\n  property({ type: String })\n], FieldLabel.prototype, \"for\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], FieldLabel.prototype, \"required\", 2);\n__decorateClass([\n  query(\"slot\")\n], FieldLabel.prototype, \"slotEl\", 2);\n__decorateClass([\n  property({ type: String, reflect: true, attribute: \"side-aligned\" })\n], FieldLabel.prototype, \"sideAligned\", 2);\n//# sourceMappingURL=FieldLabel.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport { html } from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { ifDefined } from \"@spectrum-web-components/base/src/directives.js\";\nimport { IconsetRegistry } from \"@spectrum-web-components/iconset/src/iconset-registry.js\";\nimport { IconBase } from \"./IconBase.dev.js\";\nexport class Icon extends IconBase {\n  constructor() {\n    super(...arguments);\n    this.iconsetListener = (event) => {\n      if (!this.name) {\n        return;\n      }\n      const icon = this.parseIcon(this.name);\n      if (event.detail.name === icon.iconset) {\n        this.updateIconPromise = this.updateIcon();\n      }\n    };\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    window.addEventListener(\"sp-iconset-added\", this.iconsetListener);\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    window.removeEventListener(\"sp-iconset-added\", this.iconsetListener);\n  }\n  firstUpdated() {\n    this.updateIconPromise = this.updateIcon();\n  }\n  attributeChangedCallback(name, old, value) {\n    super.attributeChangedCallback(name, old, value);\n    this.updateIconPromise = this.updateIcon();\n  }\n  announceIconImageSrcError() {\n    this.dispatchEvent(\n      new Event(\"error\", {\n        cancelable: false,\n        bubbles: false,\n        composed: false\n      })\n    );\n  }\n  render() {\n    if (this.name) {\n      return html`\n        <div id=\"container\"></div>\n      `;\n    } else if (this.src) {\n      return html`\n        <img\n          src=${this.src}\n          alt=${ifDefined(this.label)}\n          @error=${this.announceIconImageSrcError}\n        />\n      `;\n    }\n    return super.render();\n  }\n  async updateIcon() {\n    if (this.updateIconPromise) {\n      await this.updateIconPromise;\n    }\n    if (!this.name) {\n      return Promise.resolve();\n    }\n    const icon = this.parseIcon(this.name);\n    const iconset = IconsetRegistry.getInstance().getIconset(icon.iconset);\n    if (!iconset) {\n      return Promise.resolve();\n    }\n    if (!this.iconContainer) {\n      return Promise.resolve();\n    }\n    this.iconContainer.innerHTML = \"\";\n    return iconset.applyIconToElement(\n      this.iconContainer,\n      icon.icon,\n      this.size || \"\",\n      this.label ? this.label : \"\"\n    );\n  }\n  parseIcon(icon) {\n    const iconParts = icon.split(\":\");\n    let iconsetName = \"default\";\n    let iconName = icon;\n    if (iconParts.length > 1) {\n      iconsetName = iconParts[0];\n      iconName = iconParts[1];\n    }\n    return { iconset: iconsetName, icon: iconName };\n  }\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    await this.updateIconPromise;\n    return complete;\n  }\n}\n__decorateClass([\n  property()\n], Icon.prototype, \"src\", 2);\n__decorateClass([\n  property()\n], Icon.prototype, \"name\", 2);\n__decorateClass([\n  query(\"#container\")\n], Icon.prototype, \"iconContainer\", 2);\n//# sourceMappingURL=Icon.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  state\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport {\n  SystemResolutionController,\n  systemResolverUpdatedSymbol\n} from \"@spectrum-web-components/reactive-controllers/src/SystemContextResolution.js\";\nimport iconStyles from \"./icon.css.js\";\nexport class IconBase extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.unsubscribeSystemContext = null;\n    this.spectrumVersion = 1;\n    this.label = \"\";\n    this.systemResolver = new SystemResolutionController(this);\n  }\n  static get styles() {\n    return [iconStyles];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this.unsubscribeSystemContext) {\n      this.unsubscribeSystemContext();\n      this.unsubscribeSystemContext = null;\n    }\n  }\n  update(changes) {\n    if (changes.has(\"label\")) {\n      if (this.label) {\n        this.removeAttribute(\"aria-hidden\");\n      } else {\n        this.setAttribute(\"aria-hidden\", \"true\");\n      }\n    }\n    if (changes.has(systemResolverUpdatedSymbol)) {\n      this.spectrumVersion = this.systemResolver.system === \"spectrum-two\" ? 2 : 1;\n    }\n    super.update(changes);\n  }\n  render() {\n    return html`\n      <slot></slot>\n    `;\n  }\n}\n__decorateClass([\n  state()\n], IconBase.prototype, \"spectrumVersion\", 2);\n__decorateClass([\n  property({ reflect: true })\n], IconBase.prototype, \"label\", 2);\n__decorateClass([\n  property({ reflect: true })\n], IconBase.prototype, \"size\", 2);\n//# sourceMappingURL=IconBase.dev.js.map\n","\"use strict\";import{css as c}from\"@spectrum-web-components/base\";const e=c`\n    .spectrum-UIIcon-Checkmark50{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-50)}.spectrum-UIIcon-Checkmark75{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-75)}.spectrum-UIIcon-Checkmark100{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-100)}.spectrum-UIIcon-Checkmark200{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-200)}.spectrum-UIIcon-Checkmark300{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-300)}.spectrum-UIIcon-Checkmark400{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-400)}.spectrum-UIIcon-Checkmark500{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-500)}.spectrum-UIIcon-Checkmark600{--spectrum-icon-size:var(--spectrum-checkmark-icon-size-600)}\n`;export default e;\n//# sourceMappingURL=spectrum-icon-checkmark.css.js.map\n","\"use strict\";import{css as e}from\"@spectrum-web-components/base\";const r=e`\n    .spectrum-UIIcon-ChevronRight50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50)}.spectrum-UIIcon-ChevronRight75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75)}.spectrum-UIIcon-ChevronRight100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100)}.spectrum-UIIcon-ChevronRight200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200)}.spectrum-UIIcon-ChevronRight300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300)}.spectrum-UIIcon-ChevronRight400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400)}.spectrum-UIIcon-ChevronRight500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500)}.spectrum-UIIcon-ChevronDown50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400);transform:rotate(90deg)}.spectrum-UIIcon-ChevronDown500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500);transform:rotate(90deg)}.spectrum-UIIcon-ChevronLeft50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400);transform:rotate(180deg)}.spectrum-UIIcon-ChevronLeft500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500);transform:rotate(180deg)}.spectrum-UIIcon-ChevronUp50{--spectrum-icon-size:var(--spectrum-chevron-icon-size-50);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp75{--spectrum-icon-size:var(--spectrum-chevron-icon-size-75);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp100{--spectrum-icon-size:var(--spectrum-chevron-icon-size-100);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp200{--spectrum-icon-size:var(--spectrum-chevron-icon-size-200);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp300{--spectrum-icon-size:var(--spectrum-chevron-icon-size-300);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp400{--spectrum-icon-size:var(--spectrum-chevron-icon-size-400);transform:rotate(270deg)}.spectrum-UIIcon-ChevronUp500{--spectrum-icon-size:var(--spectrum-chevron-icon-size-500);transform:rotate(270deg)}\n`;export default r;\n//# sourceMappingURL=spectrum-icon-chevron.css.js.map\n","\"use strict\";import{tag as a}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Asterisk100Icon=({width:l=24,height:t=24,hidden:e=!1,title:r=\"Asterisk100\"}={})=>a`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 8 8\"\n    aria-hidden=${e?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${r}\"\n    width=\"${l}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M6.575 6.555c.055.056.092.13 0 .2l-1.149.741c-.092.056-.129.019-.166-.074L3.834 4.94 1.963 7c-.019.036-.074.073-.129 0l-.889-.927c-.093-.055-.074-.111 0-.166l2.111-1.76L.648 3.24c-.037 0-.092-.074-.056-.167l.63-1.259a.097.097 0 0 1 .167-.036L3.5 3.148l.13-2.7a.1.1 0 0 1 .081-.111h.03l1.537.2c.093 0 .111.037.093.13l-.723 2.647 2.445-.741c.055-.037.111-.037.148.074l.241 1.37c.018.093 0 .13-.074.13l-2.556.2z\"\n    />\n  </svg>`;\n//# sourceMappingURL=Asterisk100.js.map\n","\"use strict\";import{html as e}from\"@spectrum-web-components/base\";import{IconBase as t}from\"@spectrum-web-components/icon\";import{setCustomTemplateLiteralTag as r}from\"../custom-tag.js\";import{Asterisk100Icon as s}from\"../icons-s2/Asterisk100.js\";import{Asterisk100Icon as l}from\"../icons/Asterisk100.js\";export class IconAsterisk100 extends t{render(){return r(e),this.spectrumVersion===2?s({hidden:!this.label,title:this.label}):l({hidden:!this.label,title:this.label})}}\n//# sourceMappingURL=IconAsterisk100.js.map\n","\"use strict\";import{tag as r}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Checkmark100Icon=({width:e=24,height:t=24,hidden:a=!1,title:l=\"Checkmark100\"}={})=>r`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 10 10\"\n    aria-hidden=${a?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${l}\"\n    width=\"${e}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M3.5 9.5a1 1 0 0 1-.774-.368l-2.45-3a1 1 0 1 1 1.548-1.264l1.657 2.028 4.68-6.01A1 1 0 0 1 9.74 2.114l-5.45 7a1 1 0 0 1-.777.386z\"\n    />\n  </svg>`;\n//# sourceMappingURL=Checkmark100.js.map\n","\"use strict\";import{html as e}from\"@spectrum-web-components/base\";import{IconBase as t}from\"@spectrum-web-components/icon\";import{setCustomTemplateLiteralTag as r}from\"../custom-tag.js\";import{Checkmark100Icon as l}from\"../icons-s2/Checkmark100.js\";import{Checkmark100Icon as a}from\"../icons/Checkmark100.js\";export class IconCheckmark100 extends t{render(){return r(e),this.spectrumVersion===2?l({hidden:!this.label,title:this.label}):a({hidden:!this.label,title:this.label})}}\n//# sourceMappingURL=IconCheckmark100.js.map\n","\"use strict\";import{tag as l}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Chevron100Icon=({width:e=24,height:t=24,hidden:r=!1,title:a=\"Chevron100\"}={})=>l`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 10 10\"\n    aria-hidden=${r?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${a}\"\n    width=\"${e}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M3 9.95a.875.875 0 0 1-.615-1.498L5.88 5 2.385 1.547A.875.875 0 0 1 3.615.302L7.74 4.377a.876.876 0 0 1 0 1.246L3.615 9.698A.87.87 0 0 1 3 9.95\"\n    />\n  </svg>`;\n//# sourceMappingURL=Chevron100.js.map\n","\"use strict\";import{html as e}from\"@spectrum-web-components/base\";import{IconBase as t}from\"@spectrum-web-components/icon\";import{setCustomTemplateLiteralTag as r}from\"../custom-tag.js\";import{Chevron100Icon as o}from\"../icons-s2/Chevron100.js\";import{Chevron100Icon as l}from\"../icons/Chevron100.js\";export class IconChevron100 extends t{render(){return r(e),this.spectrumVersion===2?o({hidden:!this.label,title:this.label}):l({hidden:!this.label,title:this.label})}}\n//# sourceMappingURL=IconChevron100.js.map\n","\"use strict\";import{tag as a}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Asterisk100Icon=({width:l=24,height:t=24,hidden:e=!1,title:r=\"Asterisk100\"}={})=>a`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 8 8\"\n    aria-hidden=${e?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${r}\"\n    width=\"${l}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M6.575 6.555c.055.056.092.13 0 .2l-1.149.741c-.092.056-.129.019-.166-.074L3.834 4.94 1.963 7c-.019.036-.074.073-.129 0l-.889-.927c-.093-.055-.074-.111 0-.166l2.111-1.76L.648 3.24c-.037 0-.092-.074-.056-.167l.63-1.259a.097.097 0 0 1 .167-.036L3.5 3.148l.13-2.7a.1.1 0 0 1 .081-.111h.03l1.537.2c.093 0 .111.037.093.13l-.723 2.647 2.445-.741c.055-.037.111-.037.148.074l.241 1.37c.018.093 0 .13-.074.13l-2.556.2z\"\n    />\n  </svg>`;\n//# sourceMappingURL=Asterisk100.js.map\n","\"use strict\";import{tag as r}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Checkmark100Icon=({width:e=24,height:t=24,hidden:a=!1,title:l=\"Checkmark100\"}={})=>r`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 10 10\"\n    aria-hidden=${a?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${l}\"\n    width=\"${e}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M3.5 9.5a1 1 0 0 1-.774-.368l-2.45-3a1 1 0 1 1 1.548-1.264l1.657 2.028 4.68-6.01A1 1 0 0 1 9.74 2.114l-5.45 7a1 1 0 0 1-.777.386z\"\n    />\n  </svg>`;\n//# sourceMappingURL=Checkmark100.js.map\n","\"use strict\";import{tag as l}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Chevron100Icon=({width:e=24,height:t=24,hidden:r=!1,title:a=\"Chevron100\"}={})=>l`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 10 10\"\n    aria-hidden=${r?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${a}\"\n    width=\"${e}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M3 9.95a.875.875 0 0 1-.615-1.498L5.88 5 2.385 1.547A.875.875 0 0 1 3.615.302L7.74 4.377a.876.876 0 0 1 0 1.246L3.615 9.698A.87.87 0 0 1 3 9.95\"\n    />\n  </svg>`;\n//# sourceMappingURL=Chevron100.js.map\n","\"use strict\";import{tag as a}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const AlertTriangleIcon=({width:l=24,height:r=24,hidden:t=!1,title:e=\"Alert Triangle\"}={})=>a`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${l}\"\n    height=\"${r}\"\n    viewBox=\"0 0 20 20\"\n    aria-hidden=${t?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${e}\"\n  >\n    <path\n      d=\"m9.99936,15.12334c-.23065.00812-.45538-.07378-.62661-.22835-.33033-.36462-.33033-.91993,0-1.28455.16935-.15832.39483-.24279.62664-.23476.23635-.00947.46589.08026.63302.24745.16207.1677.24916.39386.24137.62681.01238.23469-.06959.4646-.2277.63864-.17358.16455-.40786.24959-.64671.23475Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"m10,11.75c-.41406,0-.75-.33594-.75-.75v-4c0-.41406.33594-.75.75-.75s.75.33594.75.75v4c0,.41406-.33594.75-.75.75Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"m16.7334,18H3.2666c-.80029,0-1.52295-.41016-1.93262-1.09766s-.42725-1.51855-.04639-2.22266L8.021,2.23242c.39355-.72754,1.15186-1.17969,1.979-1.17969s1.58545.45215,1.979,1.17969l6.7334,12.44727c.38086.7041.36328,1.53516-.04639,2.22266s-1.13232,1.09766-1.93262,1.09766ZM10,2.55273c-.13428,0-.46777.03809-.65967.39258L2.60693,15.39258c-.18311.33887-.05029.63184.01562.74121.06543.11035.25928.36621.64404.36621h13.4668c.38477,0,.57861-.25586.64404-.36621.06592-.10938.19873-.40234.01562-.74121L10.65967,2.94531c-.19189-.35449-.52539-.39258-.65967-.39258Z\"\n      fill=\"currentColor\"\n    />\n  </svg>`;\n//# sourceMappingURL=AlertTriangle.js.map\n","\"use strict\";import{tag as l}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const AlertIcon=({width:a=24,height:t=24,hidden:e=!1,title:r=\"Alert\"}={})=>l`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    height=\"${t}\"\n    viewBox=\"0 0 36 36\"\n    width=\"${a}\"\n    aria-hidden=${e?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${r}\"\n  >\n    <path\n      d=\"M17.127 2.579.4 32.512A1 1 0 0 0 1.272 34h33.456a1 1 0 0 0 .872-1.488L18.873 2.579a1 1 0 0 0-1.746 0ZM20 29.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5Zm0-6a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-12a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5Z\"\n    />\n  </svg>`;\n//# sourceMappingURL=Alert.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport { MutationController } from \"@lit-labs/observers/mutation-controller.js\";\nimport {\n  html,\n  INPUT_COMPONENT_PATTERN,\n  nothing\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport checkmarkStyles from \"@spectrum-web-components/icon/src/spectrum-icon-checkmark.css.js\";\nimport chevronStyles from \"@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js\";\nimport { SlottableRequestEvent } from \"@spectrum-web-components/overlay/src/slottable-request-event.js\";\nimport { DependencyManagerController } from \"@spectrum-web-components/reactive-controllers/src/DependencyManger.js\";\nimport {\n  ObserveSlotPresence,\n  ObserveSlotText,\n  randomID\n} from \"@spectrum-web-components/shared\";\nimport { Focusable } from \"@spectrum-web-components/shared/src/focusable.js\";\nimport { LikeAnchor } from \"@spectrum-web-components/shared/src/like-anchor.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-checkmark100.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js\";\nimport menuItemStyles from \"./menu-item.css.js\";\nconst POINTERLEAVE_TIMEOUT = 100;\nexport class MenuItemAddedOrUpdatedEvent extends Event {\n  constructor(item) {\n    super(\"sp-menu-item-added-or-updated\", {\n      bubbles: true,\n      composed: true\n    });\n    this.menuCascade = /* @__PURE__ */ new WeakMap();\n    this.clear(item);\n  }\n  clear(item) {\n    this._item = item;\n    this.currentAncestorWithSelects = void 0;\n    item.menuData = {\n      cleanupSteps: [],\n      focusRoot: void 0,\n      selectionRoot: void 0,\n      parentMenu: void 0\n    };\n    this.menuCascade = /* @__PURE__ */ new WeakMap();\n  }\n  get item() {\n    return this._item;\n  }\n}\nexport class MenuItemKeydownEvent extends KeyboardEvent {\n  constructor({ root, event }) {\n    super(\"sp-menu-item-keydown\", { bubbles: true, composed: true });\n    this.root = root;\n    this._event = event;\n  }\n  get altKey() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.altKey) || false;\n  }\n  get code() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.code) || \"\";\n  }\n  get ctrlKey() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.ctrlKey) || false;\n  }\n  get isComposing() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.isComposing) || false;\n  }\n  get key() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.key) || \"\";\n  }\n  get location() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.location) || 0;\n  }\n  get metaKey() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.metaKey) || false;\n  }\n  get repeat() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.repeat) || false;\n  }\n  get shiftKey() {\n    var _a;\n    return ((_a = this._event) == null ? void 0 : _a.shiftKey) || false;\n  }\n}\nexport class MenuItem extends LikeAnchor(\n  ObserveSlotText(ObserveSlotPresence(Focusable, '[slot=\"icon\"]'))\n) {\n  constructor() {\n    super();\n    this.active = false;\n    this.dependencyManager = new DependencyManagerController(this);\n    this.focused = false;\n    this.selected = false;\n    this._value = \"\";\n    this.hasSubmenu = false;\n    this.noWrap = false;\n    this.open = false;\n    /**\n     * whether menu item's submenu is opened via keyboard\n     */\n    this._openedViaKeyboard = false;\n    /**\n     * whether menu item's submenu is closed via pointer leave\n     */\n    this._closedViaPointer = false;\n    this._touchHandledViaPointerup = false;\n    this.handleSlottableRequest = (event) => {\n      var _a;\n      (_a = this.submenuElement) == null ? void 0 : _a.dispatchEvent(\n        new SlottableRequestEvent(event.name, event.data)\n      );\n    };\n    this.proxyFocus = () => {\n      this.focus();\n    };\n    this.handleTouchSubmenuToggle = (event) => {\n      var _a;\n      if (event.pointerId !== this._activePointerId) {\n        return;\n      }\n      (_a = this._touchAbortController) == null ? void 0 : _a.abort();\n      this._touchHandledViaPointerup = true;\n      this._activePointerId = void 0;\n      if (this.open) {\n        this.open = false;\n      } else {\n        this.openOverlay();\n      }\n      setTimeout(() => {\n        this._touchHandledViaPointerup = false;\n      }, 0);\n    };\n    this.handleTouchCleanup = (event) => {\n      var _a;\n      if (event.pointerId !== this._activePointerId) {\n        return;\n      }\n      (_a = this._touchAbortController) == null ? void 0 : _a.abort();\n      this._activePointerId = void 0;\n      this._touchHandledViaPointerup = false;\n    };\n    /**\n     * forward key info from keydown event to parent menu\n     */\n    this.handleKeydown = (event) => {\n      const { target, key } = event;\n      const openSubmenuKey = this.hasSubmenu && !this.open && [\" \", \"Enter\"].includes(key);\n      if (target === this) {\n        if ([\"ArrowLeft\", \"ArrowRight\", \"Escape\"].includes(key) || openSubmenuKey) {\n          event.preventDefault();\n        }\n        this.dispatchEvent(\n          new MenuItemKeydownEvent({ root: this, event })\n        );\n      }\n    };\n    this.handleBeforetoggle = (event) => {\n      if (event.newState === \"closed\") {\n        this.open = true;\n        this.overlayElement.manuallyKeepOpen();\n        this.overlayElement.removeEventListener(\n          \"beforetoggle\",\n          this.handleBeforetoggle\n        );\n      }\n    };\n    this.recentlyLeftChild = false;\n    this.willDispatchUpdate = false;\n    this.menuData = {\n      // menu that controls ArrowUp/ArrowDown navigation\n      focusRoot: void 0,\n      parentMenu: void 0,\n      // menu or menu group that controls selection\n      selectionRoot: void 0,\n      cleanupSteps: []\n    };\n    this.addEventListener(\"click\", this.handleClickCapture, {\n      capture: true\n    });\n    this.addEventListener(\"focus\", this.handleFocus);\n    this.addEventListener(\"blur\", this.handleBlur);\n    new MutationController(this, {\n      config: {\n        characterData: true,\n        childList: true,\n        subtree: true,\n        attributeFilter: [\"src\"]\n      },\n      callback: (mutations) => {\n        const isSubmenu = mutations.every(\n          (mutation) => mutation.target.slot === \"submenu\"\n        );\n        if (isSubmenu) {\n          return;\n        }\n        this.breakItemChildrenCache();\n      }\n    });\n  }\n  static get styles() {\n    return [menuItemStyles, checkmarkStyles, chevronStyles];\n  }\n  get value() {\n    return this._value || this.itemText;\n  }\n  set value(value) {\n    if (value === this._value) {\n      return;\n    }\n    this._value = value || \"\";\n    if (this._value) {\n      this.setAttribute(\"value\", this._value);\n    } else {\n      this.removeAttribute(\"value\");\n    }\n  }\n  /**\n   * @private\n   * text content of the menu item minus whitespace\n   */\n  get itemText() {\n    return this.itemChildren.content.reduce(\n      (acc, node) => acc + (node.textContent || \"\").trim(),\n      \"\"\n    );\n  }\n  /**\n   * the focusable element of the menu item\n   */\n  get focusElement() {\n    return this;\n  }\n  get hasIcon() {\n    return this.slotContentIsPresent;\n  }\n  get itemChildren() {\n    if (!this.iconSlot || !this.contentSlot) {\n      return {\n        icon: [],\n        content: []\n      };\n    }\n    if (this._itemChildren) {\n      return this._itemChildren;\n    }\n    const icon = this.iconSlot.assignedElements().map((element) => {\n      const newElement = element.cloneNode(true);\n      newElement.removeAttribute(\"slot\");\n      newElement.classList.toggle(\"icon\");\n      return newElement;\n    });\n    const content = this.contentSlot.assignedNodes().map((node) => node.cloneNode(true));\n    this._itemChildren = { icon, content };\n    return this._itemChildren;\n  }\n  handleClickCapture(event) {\n    if (this.disabled) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      return false;\n    }\n    if (this.shouldProxyClick()) {\n      return;\n    }\n  }\n  shouldProxyClick() {\n    let handled = false;\n    if (this.anchorElement) {\n      this.anchorElement.click();\n      handled = true;\n    }\n    return handled;\n  }\n  breakItemChildrenCache() {\n    this._itemChildren = void 0;\n    this.triggerUpdate();\n  }\n  renderSubmenu() {\n    const slot = html`\n      <slot\n        name=\"submenu\"\n        @slotchange=${this.manageSubmenu}\n        @sp-menu-item-added-or-updated=${{\n      handleEvent: (event) => {\n        event.clear(event.item);\n      },\n      capture: true\n    }}\n        @focusin=${(event) => event.stopPropagation()}\n      ></slot>\n    `;\n    if (!this.hasSubmenu) {\n      return slot;\n    }\n    this.dependencyManager.add(\"sp-overlay\");\n    this.dependencyManager.add(\"sp-popover\");\n    import(\"@spectrum-web-components/overlay/sp-overlay.js\");\n    import(\"@spectrum-web-components/popover/sp-popover.js\");\n    return html`\n      <sp-overlay\n        receives-focus=\"false\"\n        .triggerElement=${this}\n        ?disabled=${!this.hasSubmenu}\n        ?open=${this.hasSubmenu && this.open && this.dependencyManager.loaded}\n        .placement=${this.dir === \"ltr\" ? \"right-start\" : \"left-start\"}\n        receives-focus=\"false\"\n        .offset=${[-10, 0]}\n        .type=${\"auto\"}\n        @close=${(event) => event.stopPropagation()}\n        @slottable-request=${this.handleSlottableRequest}\n      >\n        <sp-popover\n          @change=${(event) => {\n      this.handleSubmenuChange(event);\n      this.open = false;\n    }}\n          @pointerenter=${this.handleSubmenuPointerenter}\n          @pointerleave=${this.handleSubmenuPointerleave}\n          @sp-menu-item-added-or-updated=${(event) => event.stopPropagation()}\n        >\n          ${slot}\n        </sp-popover>\n      </sp-overlay>\n      <sp-icon-chevron100\n        class=\"spectrum-UIIcon-ChevronRight100 chevron icon\"\n      ></sp-icon-chevron100>\n    `;\n  }\n  render() {\n    return html`\n      ${this.selected ? html`\n            <sp-icon-checkmark100\n              id=\"selected\"\n              class=\"spectrum-UIIcon-Checkmark100\n                            icon\n                            checkmark\n                            ${this.hasIcon ? \"checkmark--withAdjacentIcon\" : \"\"}\"\n            ></sp-icon-checkmark100>\n          ` : nothing}\n      <slot name=\"icon\"></slot>\n      <div id=\"label\">\n        <slot id=\"slot\"></slot>\n      </div>\n      <slot name=\"description\"></slot>\n      <slot name=\"value\"></slot>\n      ${this.href && this.href.length > 0 ? super.renderAnchor({\n      id: \"button\",\n      ariaHidden: true,\n      className: \"button anchor hidden\"\n    }) : nothing}\n      ${this.renderSubmenu()}\n    `;\n  }\n  /**\n   * determines if item has a submenu and updates the `aria-haspopup` attribute\n   */\n  manageSubmenu(event) {\n    this.submenuElement = event.target.assignedElements({\n      flatten: true\n    })[0];\n    this.hasSubmenu = !!this.submenuElement;\n    if (this.hasSubmenu) {\n      this.setAttribute(\"aria-haspopup\", \"true\");\n    }\n  }\n  handlePointerdown(event) {\n    var _a;\n    const path = event.composedPath();\n    const targetIsInOverlay = this.overlayElement && path.includes(this.overlayElement);\n    if (event.pointerType === \"touch\" && this.hasSubmenu && !targetIsInOverlay && this._activePointerId === void 0) {\n      this._activePointerId = event.pointerId;\n      this._touchAbortController = new AbortController();\n      window.addEventListener(\"pointerup\", this.handleTouchSubmenuToggle, {\n        once: true,\n        signal: this._touchAbortController.signal\n      });\n      window.addEventListener(\"pointercancel\", this.handleTouchCleanup, {\n        once: true,\n        signal: this._touchAbortController.signal\n      });\n    }\n    if (!targetIsInOverlay && this.hasSubmenu && this.open && event.pointerType !== \"touch\") {\n      this.addEventListener(\"focus\", this.handleSubmenuFocus, {\n        once: true\n      });\n      (_a = this.overlayElement) == null ? void 0 : _a.addEventListener(\n        \"beforetoggle\",\n        this.handleBeforetoggle\n      );\n    }\n  }\n  firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.setAttribute(\"tabindex\", \"-1\");\n    this.addEventListener(\"keydown\", this.handleKeydown);\n    this.addEventListener(\"mouseover\", this.handleMouseover);\n    this.addEventListener(\"pointerdown\", this.handlePointerdown);\n    this.addEventListener(\"pointerenter\", this.closeOverlaysForRoot);\n    if (!this.hasAttribute(\"id\")) {\n      this.id = `sp-menu-item-${randomID()}`;\n    }\n  }\n  getActiveElementSafely() {\n    let root = this.getRootNode();\n    let activeElement = root.activeElement;\n    if (!activeElement && root !== document) {\n      while (root && root !== document && \"host\" in root) {\n        root = root.host.getRootNode();\n        activeElement = root.activeElement;\n        if (activeElement) {\n          break;\n        }\n      }\n    }\n    return activeElement;\n  }\n  handleMouseover(event) {\n    const target = event.target;\n    if (target === this) {\n      const activeElement = this.getActiveElementSafely();\n      if (!activeElement || !this.isInputElement(activeElement)) {\n        this.focus();\n      }\n      this.focused = false;\n    }\n  }\n  /**\n   * Determines if an element is an input field that should retain focus.\n   * Uses multiple detection strategies to identify input elements generically.\n   */\n  isInputElement(element) {\n    if (this.isNativeInputElement(element)) {\n      return true;\n    }\n    if (element.contentEditable === \"true\") {\n      return true;\n    }\n    if (this.isSpectrumInputComponent(element)) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks if an element is a native HTML input element.\n   */\n  isNativeInputElement(element) {\n    return element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement;\n  }\n  /**\n   * Checks if an element is a Spectrum Web Component with input behavior.\n   * Uses ARIA roles and component patterns for generic detection.\n   */\n  isSpectrumInputComponent(element) {\n    if (!element.tagName.startsWith(\"SP-\")) {\n      return false;\n    }\n    const role = element.getAttribute(\"role\");\n    const inputRoles = [\"textbox\", \"searchbox\", \"combobox\", \"slider\"];\n    if (role && inputRoles.includes(role)) {\n      return true;\n    }\n    const inputComponentPattern = INPUT_COMPONENT_PATTERN;\n    if (inputComponentPattern.test(element.tagName)) {\n      return true;\n    }\n    return false;\n  }\n  closeOverlaysForRoot() {\n    var _a;\n    if (this.open) {\n      return;\n    }\n    (_a = this.menuData.parentMenu) == null ? void 0 : _a.closeDescendentOverlays();\n  }\n  handleFocus(event) {\n    const { target } = event;\n    if (target === this) {\n      this.focused = true;\n    }\n  }\n  handleBlur(event) {\n    const { target } = event;\n    if (target === this) {\n      this.focused = false;\n    }\n  }\n  handleSubmenuClick(event) {\n    if (this._touchHandledViaPointerup) {\n      event.stopPropagation();\n      event.preventDefault();\n      return;\n    }\n    if (event.composedPath().includes(this.overlayElement)) {\n      return;\n    }\n    this.openOverlay(true);\n  }\n  handleSubmenuFocus() {\n    requestAnimationFrame(() => {\n      this.overlayElement.open = this.open;\n      this.focused = false;\n    });\n  }\n  handlePointerenter(event) {\n    if (event.pointerType === \"touch\") {\n      return;\n    }\n    if (this.leaveTimeout) {\n      clearTimeout(this.leaveTimeout);\n      delete this.leaveTimeout;\n      this.recentlyLeftChild = false;\n      return;\n    }\n    this.focus();\n    this.openOverlay();\n  }\n  handlePointerleave(event) {\n    if (event.pointerType === \"touch\") {\n      return;\n    }\n    this._closedViaPointer = true;\n    if (this.open && !this.recentlyLeftChild) {\n      this.leaveTimeout = setTimeout(() => {\n        delete this.leaveTimeout;\n        this.open = false;\n      }, POINTERLEAVE_TIMEOUT);\n    }\n  }\n  /**\n   * When there is a `change` event in the submenu for this item\n   * then we \"click\" this item to cascade the selection up the\n   * menu tree allowing all submenus between the initial selection\n   * and the root of the tree to have their selection changes and\n   * be closed.\n   */\n  handleSubmenuChange(event) {\n    var _a;\n    event.stopPropagation();\n    (_a = this.menuData.selectionRoot) == null ? void 0 : _a.selectOrToggleItem(this);\n  }\n  handleSubmenuPointerenter() {\n    this.recentlyLeftChild = true;\n  }\n  async handleSubmenuPointerleave() {\n    this.recentlyLeftChild = false;\n  }\n  handleSubmenuOpen(event) {\n    var _a;\n    const parentOverlay = event.composedPath().find((el) => {\n      return el !== this.overlayElement && el.localName === \"sp-overlay\";\n    });\n    if (this._openedViaKeyboard) {\n      (_a = this.submenuElement) == null ? void 0 : _a.focus();\n    }\n    this.overlayElement.parentOverlayToForceClose = parentOverlay;\n  }\n  cleanup() {\n    this._closedViaPointer = false;\n    this.setAttribute(\"aria-expanded\", \"false\");\n    this.open = false;\n    this.active = false;\n  }\n  async openOverlay(shouldFocus = false) {\n    if (!this.hasSubmenu || this.open || this.disabled) {\n      return;\n    }\n    this.open = true;\n    this.active = true;\n    this.setAttribute(\"aria-expanded\", \"true\");\n    this._openedViaKeyboard = shouldFocus;\n    this.addEventListener(\"sp-closed\", this.cleanup, {\n      once: true\n    });\n  }\n  updateAriaSelected() {\n    const role = this.getAttribute(\"role\");\n    if (role === \"option\") {\n      this.setAttribute(\"aria-selected\", this.selected ? \"true\" : \"false\");\n    } else if (role === \"menuitemcheckbox\" || role === \"menuitemradio\") {\n      this.setAttribute(\"aria-checked\", this.selected ? \"true\" : \"false\");\n    }\n  }\n  setRole(role) {\n    this.setAttribute(\"role\", role);\n    this.updateAriaSelected();\n  }\n  willUpdate(changes) {\n    super.updated(changes);\n    if (changes.has(\"open\") && !this.open && this.hasSubmenu && !this._closedViaPointer && this.matches(\":focus-within\")) {\n      this.focus();\n    }\n  }\n  updated(changes) {\n    var _a, _b;\n    super.updated(changes);\n    if (changes.has(\"label\") && (this.label || typeof changes.get(\"label\") !== \"undefined\")) {\n      this.setAttribute(\"aria-label\", this.label || \"\");\n    }\n    if (changes.has(\"active\") && (this.active || typeof changes.get(\"active\") !== \"undefined\")) {\n      if (this.active) {\n        (_a = this.menuData.selectionRoot) == null ? void 0 : _a.closeDescendentOverlays();\n      }\n    }\n    if (this.anchorElement) {\n      this.anchorElement.addEventListener(\"focus\", this.proxyFocus);\n      this.anchorElement.tabIndex = -1;\n    }\n    if (changes.has(\"selected\")) {\n      this.updateAriaSelected();\n    }\n    if (changes.has(\"hasSubmenu\") && (this.hasSubmenu || typeof changes.get(\"hasSubmenu\") !== \"undefined\")) {\n      if (this.hasSubmenu) {\n        this.abortControllerSubmenu = new AbortController();\n        const options = { signal: this.abortControllerSubmenu.signal };\n        this.addEventListener(\"click\", this.handleSubmenuClick, options);\n        this.addEventListener(\"pointerenter\", this.handlePointerenter, options);\n        this.addEventListener(\"pointerleave\", this.handlePointerleave, options);\n        this.addEventListener(\"sp-opened\", this.handleSubmenuOpen, options);\n      } else {\n        (_b = this.abortControllerSubmenu) == null ? void 0 : _b.abort();\n      }\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.triggerUpdate();\n  }\n  disconnectedCallback() {\n    var _a;\n    this.menuData.cleanupSteps.forEach((removal) => removal(this));\n    this.menuData = {\n      focusRoot: void 0,\n      parentMenu: void 0,\n      selectionRoot: void 0,\n      cleanupSteps: []\n    };\n    (_a = this._touchAbortController) == null ? void 0 : _a.abort();\n    this._activePointerId = void 0;\n    this._touchHandledViaPointerup = false;\n    super.disconnectedCallback();\n  }\n  async triggerUpdate() {\n    if (this.willDispatchUpdate) {\n      return;\n    }\n    this.willDispatchUpdate = true;\n    await new Promise((ready) => requestAnimationFrame(ready));\n    this.dispatchUpdate();\n  }\n  focus() {\n    super.focus();\n    this.dispatchEvent(new FocusEvent(\"focus\"));\n  }\n  blur() {\n    this.dispatchEvent(new FocusEvent(\"blur\"));\n    super.blur();\n  }\n  dispatchUpdate() {\n    if (!this.isConnected) {\n      return;\n    }\n    this.dispatchEvent(new MenuItemAddedOrUpdatedEvent(this));\n    this.willDispatchUpdate = false;\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], MenuItem.prototype, \"active\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], MenuItem.prototype, \"focused\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], MenuItem.prototype, \"selected\", 2);\n__decorateClass([\n  property({ type: String })\n], MenuItem.prototype, \"value\", 1);\n__decorateClass([\n  property({ type: Boolean, reflect: true, attribute: \"has-submenu\" })\n], MenuItem.prototype, \"hasSubmenu\", 2);\n__decorateClass([\n  query(\"slot:not([name])\")\n], MenuItem.prototype, \"contentSlot\", 2);\n__decorateClass([\n  query('slot[name=\"icon\"]')\n], MenuItem.prototype, \"iconSlot\", 2);\n__decorateClass([\n  property({\n    type: Boolean,\n    reflect: true,\n    attribute: \"no-wrap\",\n    hasChanged() {\n      return false;\n    }\n  })\n], MenuItem.prototype, \"noWrap\", 2);\n__decorateClass([\n  query(\".anchor\")\n], MenuItem.prototype, \"anchorElement\", 2);\n__decorateClass([\n  query(\"sp-overlay\")\n], MenuItem.prototype, \"overlayElement\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], MenuItem.prototype, \"open\", 2);\n//# sourceMappingURL=MenuItem.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SizedMixin,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { RovingTabindexController } from \"@spectrum-web-components/reactive-controllers/src/RovingTabindex.js\";\nimport menuStyles from \"./menu.css.js\";\nexport class Menu extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {\n  constructor() {\n    super();\n    /**\n     * iPad scroll detection properties\n     *\n     * This feature prevents menu item selection during iPad scrolling to avoid\n     * accidental selections when users are trying to scroll through a long menu.\n     *\n     * How it works:\n     * 1. On touchstart: Record initial Y position and timestamp\n     * 2. On touchmove: Calculate vertical movement and time elapsed\n     * 3. If movement > threshold AND time < threshold: Mark as scrolling\n     * 4. On touchend: Reset scrolling state after a delay\n     * 5. During selection: Prevent selection if scrolling is detected\n     *\n     * This prevents the common iPad issue where users accidentally select menu\n     * items while trying to scroll through the menu content.\n     *\n     * Threshold Values:\n     * - Movement threshold: 10px (consistent with Card component click vs. drag detection)\n     * - Time threshold: 300ms (consistent with longpress duration across the design system)\n     * - Reset delay: 100ms (allows final touch events to be processed)\n     *\n     * These values are carefully chosen to balance preventing accidental triggers\n     * while allowing intentional scroll gestures. They represent a common UX pattern\n     * in mobile interfaces and are consistent with other components in the design system.\n     */\n    this.touchStartY = void 0;\n    this.touchStartTime = void 0;\n    this.isCurrentlyScrolling = false;\n    /**\n     * Minimum vertical movement (in pixels) required to trigger scrolling detection.\n     *\n     * This threshold is consistent with other components in the design system:\n     * - Card component uses 10px for click vs. drag detection\n     * - Menu component uses 10px for scroll vs. selection detection\n     *\n     * The 10px threshold is carefully chosen to:\n     * - Allow for natural finger tremor and accidental touches\n     * - Distinguish between intentional scroll gestures and taps\n     * - Provide consistent behavior across the platform\n     *\n     * @see {@link packages/card/src/Card.ts} for similar threshold usage\n     */\n    this.scrollThreshold = 10;\n    // pixels\n    /**\n     * Maximum time (in milliseconds) for a movement to be considered scrolling.\n     *\n     * This threshold is consistent with other timing values in the design system:\n     * - Longpress duration: 300ms (ActionButton, LongpressController)\n     * - Scroll detection: 300ms (Menu component)\n     *\n     * Quick movements within this timeframe are likely intentional scrolls,\n     * while slower movements are more likely taps or selections.\n     *\n     * @see {@link packages/action-button/src/ActionButton.ts} for longpress duration\n     * @see {@link packages/overlay/src/LongpressController.ts} for longpress duration\n     */\n    this.scrollTimeThreshold = 300;\n    this.label = \"\";\n    this.ignore = false;\n    this.value = \"\";\n    this.valueSeparator = \",\";\n    this._selected = [];\n    this.selectedItems = [];\n    this.childItemSet = /* @__PURE__ */ new Set();\n    this.focusedItemIndex = 0;\n    this.focusInItemIndex = 0;\n    /**\n     * Whether to support the pointerdown-drag-pointerup selection strategy.\n     * Defaults to false to prevent click/touch events from being captured\n     * behind the menu tray in mobile environments (since the menu closes\n     * immediately on pointerup).\n     */\n    this.shouldSupportDragAndSelect = false;\n    this.selectedItemsMap = /* @__PURE__ */ new Map();\n    // if the click and pointerup events are on the same target, we should not\n    // handle the click event.\n    this.pointerUpTarget = null;\n    this.descendentOverlays = /* @__PURE__ */ new Map();\n    this.handleSubmenuClosed = (event) => {\n      event.stopPropagation();\n      const target = event.composedPath()[0];\n      target.dispatchEvent(\n        new Event(\"sp-menu-submenu-closed\", {\n          bubbles: true,\n          composed: true\n        })\n      );\n    };\n    this.handleSubmenuOpened = (event) => {\n      event.stopPropagation();\n      const target = event.composedPath()[0];\n      target.dispatchEvent(\n        new Event(\"sp-menu-submenu-opened\", {\n          bubbles: true,\n          composed: true\n        })\n      );\n      const openedItem = event.composedPath().find((el) => this.childItemSet.has(el));\n      if (!openedItem) {\n        return;\n      }\n    };\n    this._hasUpdatedSelectedItemIndex = false;\n    this._willUpdateItems = false;\n    this.cacheUpdated = Promise.resolve();\n    /* c8 ignore next 3 */\n    this.resolveCacheUpdated = () => {\n      return;\n    };\n    if (!this.rovingTabindexController && this.controlsRovingTabindex) {\n      this.rovingTabindexController = new RovingTabindexController(\n        this,\n        {\n          direction: \"vertical\",\n          focusInIndex: (elements) => {\n            let firstEnabledIndex = -1;\n            const firstSelectedIndex = elements == null ? void 0 : elements.findIndex((el, index) => {\n              if (!elements[firstEnabledIndex] && !el.disabled) {\n                firstEnabledIndex = index;\n              }\n              return el.selected && !el.disabled;\n            });\n            return elements && firstSelectedIndex && elements[firstSelectedIndex] ? firstSelectedIndex : firstEnabledIndex;\n          },\n          elements: () => this.childItems,\n          isFocusableElement: this.isFocusableElement.bind(this),\n          hostDelegatesFocus: true,\n          stopKeyEventPropagation: true\n        }\n      );\n    }\n    this.addEventListener(\n      \"sp-menu-item-added-or-updated\",\n      this.onSelectableItemAddedOrUpdated\n    );\n    this.addEventListener(\n      \"sp-menu-item-added-or-updated\",\n      this.onFocusableItemAddedOrUpdated,\n      {\n        capture: true\n      }\n    );\n    this.addEventListener(\"click\", this.handleClick);\n    this.addEventListener(\"touchend\", this.handlePointerup);\n    this.addEventListener(\"focusout\", this.handleFocusout);\n    this.addEventListener(\"sp-menu-item-keydown\", this.handleKeydown);\n    this.addEventListener(\"pointerup\", this.handlePointerup);\n    this.addEventListener(\"sp-opened\", this.handleSubmenuOpened);\n    this.addEventListener(\"sp-closed\", this.handleSubmenuClosed);\n    this.addEventListener(\"touchstart\", this.handleTouchStart, {\n      passive: true\n    });\n    this.addEventListener(\"touchmove\", this.handleTouchMove, {\n      passive: true\n    });\n  }\n  static get styles() {\n    return [menuStyles];\n  }\n  get isSubmenu() {\n    return this.slot === \"submenu\";\n  }\n  // milliseconds\n  /**\n   * Public getter for scrolling state\n   * Returns true if the component is currently in a scrolling state\n   */\n  get isScrolling() {\n    return this.isCurrentlyScrolling;\n  }\n  set isScrolling(value) {\n    this.isCurrentlyScrolling = value;\n  }\n  get selected() {\n    return !this.selects ? [] : this._selected;\n  }\n  set selected(selected) {\n    if (selected === this.selected) {\n      return;\n    }\n    const old = this.selected;\n    this._selected = selected;\n    this.selectedItems = [];\n    this.selectedItemsMap.clear();\n    this.childItems.forEach((item) => {\n      if (this !== item.menuData.selectionRoot) {\n        return;\n      }\n      item.selected = this.selected.includes(item.value);\n      if (item.selected) {\n        this.selectedItems.push(item);\n        this.selectedItemsMap.set(item, true);\n      }\n    });\n    this.requestUpdate(\"selected\", old);\n  }\n  get focusInItem() {\n    var _a;\n    return (_a = this.rovingTabindexController) == null ? void 0 : _a.focusInElement;\n  }\n  get controlsRovingTabindex() {\n    return true;\n  }\n  /**\n   * child items managed by menu\n   */\n  get childItems() {\n    if (!this.cachedChildItems) {\n      this.cachedChildItems = this.updateCachedMenuItems();\n    }\n    return this.cachedChildItems;\n  }\n  updateCachedMenuItems() {\n    var _a;\n    if (!this.menuSlot) {\n      return [];\n    }\n    const itemsList = [];\n    const slottedElements = this.menuSlot.assignedElements({\n      flatten: true\n    });\n    for (const [i, slottedElement] of slottedElements.entries()) {\n      if (this.childItemSet.has(slottedElement)) {\n        itemsList.push(slottedElement);\n        continue;\n      }\n      const isHTMLSlotElement = slottedElement.localName === \"slot\";\n      const flattenedChildren = isHTMLSlotElement ? slottedElement.assignedElements({\n        flatten: true\n      }) : [...slottedElement.querySelectorAll(`:scope > *`)];\n      slottedElements.splice(\n        i,\n        1,\n        slottedElement,\n        ...flattenedChildren\n      );\n    }\n    this.cachedChildItems = [...itemsList];\n    (_a = this.rovingTabindexController) == null ? void 0 : _a.clearElementCache();\n    return this.cachedChildItems;\n  }\n  /**\n   * Hide this getter from web-component-analyzer until\n   * https://github.com/runem/web-component-analyzer/issues/131\n   * has been addressed.\n   *\n   * @private\n   */\n  get childRole() {\n    if (this.resolvedRole === \"listbox\") {\n      return \"option\";\n    }\n    switch (this.resolvedSelects) {\n      case \"single\":\n        return \"menuitemradio\";\n      case \"multiple\":\n        return \"menuitemcheckbox\";\n      default:\n        return \"menuitem\";\n    }\n  }\n  get ownRole() {\n    return \"menu\";\n  }\n  /**\n   * When a descendant `<sp-menu-item>` element is added or updated it will dispatch\n   * this event to announce its presence in the DOM. During the CAPTURE phase the first\n   * Menu based element that the event encounters will manage the focus state of the\n   * dispatching `<sp-menu-item>` element.\n   * @param event\n   */\n  onFocusableItemAddedOrUpdated(event) {\n    event.menuCascade.set(this, {\n      hadFocusRoot: !!event.item.menuData.focusRoot,\n      ancestorWithSelects: event.currentAncestorWithSelects\n    });\n    if (this.selects) {\n      event.currentAncestorWithSelects = this;\n    }\n    event.item.menuData.focusRoot = event.item.menuData.focusRoot || this;\n  }\n  /**\n   * When a descendant `<sp-menu-item>` element is added or updated it will dispatch\n   * this event to announce its presence in the DOM. During the BUBBLE phase the first\n   * Menu based element that the event encounters that does not inherit selection will\n   * manage the selection state of the dispatching `<sp-menu-item>` element.\n   * @param event\n   */\n  onSelectableItemAddedOrUpdated(event) {\n    var _a, _b;\n    const cascadeData = event.menuCascade.get(this);\n    if (!cascadeData) {\n      return;\n    }\n    event.item.menuData.parentMenu = event.item.menuData.parentMenu || this;\n    this.addChildItem(event.item);\n    if (this.selects === \"inherit\") {\n      this.resolvedSelects = \"inherit\";\n      const ignoreMenu = (_a = event.currentAncestorWithSelects) == null ? void 0 : _a.ignore;\n      this.resolvedRole = ignoreMenu ? \"none\" : ((_b = event.currentAncestorWithSelects) == null ? void 0 : _b.getAttribute(\"role\")) || this.getAttribute(\"role\") || void 0;\n    } else if (this.selects) {\n      this.resolvedRole = this.ignore ? \"none\" : this.getAttribute(\"role\") || void 0;\n      this.resolvedSelects = this.selects;\n    } else {\n      this.resolvedRole = this.ignore ? \"none\" : this.getAttribute(\"role\") || void 0;\n      this.resolvedSelects = this.resolvedRole === \"none\" ? \"ignore\" : \"none\";\n    }\n    if (this.resolvedRole === \"none\") {\n      return;\n    }\n    const selects = this.resolvedSelects === \"single\" || this.resolvedSelects === \"multiple\";\n    event.item.menuData.cleanupSteps.push(\n      (item) => this.removeChildItem(item)\n    );\n    if ((selects || !this.selects && this.resolvedSelects !== \"ignore\") && !event.item.menuData.selectionRoot) {\n      event.item.setRole(this.childRole);\n      event.item.menuData.selectionRoot = event.item.menuData.selectionRoot || this;\n      if (event.item.selected) {\n        this.selectedItemsMap.set(event.item, true);\n        this.selectedItems = [...this.selectedItems, event.item];\n        this._selected = [...this.selected, event.item.value];\n        this.value = this.selected.join(this.valueSeparator);\n      }\n    }\n  }\n  addChildItem(item) {\n    this.childItemSet.add(item);\n    this.handleItemsChanged();\n  }\n  async removeChildItem(item) {\n    if (item.focused || item.hasAttribute(\"focused\") || item.active) {\n      this._updateFocus = this.getNeighboringFocusableElement(item);\n    }\n    this.childItemSet.delete(item);\n    this.cachedChildItems = void 0;\n  }\n  /**\n   * for picker elements, will set focus on first selected item\n   */\n  focusOnFirstSelectedItem({ preventScroll } = {}) {\n    var _a;\n    if (!this.rovingTabindexController) {\n      return;\n    }\n    const selectedItem = this.selectedItems.find(\n      (el) => this.isFocusableElement(el)\n    );\n    if (!selectedItem) {\n      this.focus({ preventScroll });\n      return;\n    }\n    if (selectedItem && !preventScroll) {\n      selectedItem.scrollIntoView({ block: \"nearest\" });\n    }\n    (_a = this.rovingTabindexController) == null ? void 0 : _a.focusOnItem(selectedItem);\n  }\n  focus({ preventScroll } = {}) {\n    if (this.rovingTabindexController) {\n      if (!this.childItems.length || this.childItems.every((childItem) => childItem.disabled)) {\n        return;\n      }\n      if (this.childItems.some(\n        (childItem) => childItem.menuData.focusRoot !== this\n      )) {\n        super.focus({ preventScroll });\n        return;\n      }\n      this.rovingTabindexController.focus({ preventScroll });\n    }\n  }\n  /**\n   * Handles touchstart events for iPad scroll detection.\n   *\n   * Records the initial touch position and timestamp to establish a baseline\n   * for detecting scroll gestures. Only processes single-touch events to\n   * avoid interference with multi-touch gestures.\n   *\n   * @param event - The TouchEvent from the touchstart event\n   */\n  handleTouchStart(event) {\n    if (event.touches.length === 1) {\n      this.touchStartY = event.touches[0].clientY;\n      this.touchStartTime = Date.now();\n      this.isCurrentlyScrolling = false;\n    }\n  }\n  /**\n   * Handles touchmove events for iPad scroll detection.\n   *\n   * Calculates the vertical movement distance and time elapsed since touchstart.\n   * If the movement exceeds the threshold (10px) and happens within the time\n   * threshold (300ms), it marks the interaction as scrolling. This helps\n   * distinguish between intentional scroll gestures and accidental touches.\n   *\n   * @param event - The TouchEvent from the touchmove event\n   */\n  handleTouchMove(event) {\n    if (event.touches.length === 1 && this.touchStartY !== void 0 && this.touchStartTime !== void 0) {\n      const currentY = event.touches[0].clientY;\n      const deltaY = Math.abs(currentY - this.touchStartY);\n      const deltaTime = Date.now() - this.touchStartTime;\n      if (deltaY > this.scrollThreshold && deltaTime < this.scrollTimeThreshold) {\n        this.isCurrentlyScrolling = true;\n      }\n    }\n  }\n  /**\n   * Handles touchend events for iPad scroll detection.\n   *\n   * Resets the scrolling state after a short delay (100ms) to allow for\n   * any final touch events to be processed. This delay prevents immediate\n   * state changes that could interfere with the selection logic.\n   *\n   * The 100ms delay is consistent with the design system's approach to\n   * touch event handling and ensures that any final touch events or\n   * gesture recognition can complete before the scrolling state is reset.\n   */\n  handleTouchEnd() {\n    setTimeout(() => {\n      this.isCurrentlyScrolling = false;\n      this.touchStartY = void 0;\n      this.touchStartTime = void 0;\n    }, 100);\n  }\n  handleFocusout() {\n    var _a;\n    if (!this.matches(\":focus-within\")) {\n      (_a = this.rovingTabindexController) == null ? void 0 : _a.reset();\n    }\n  }\n  handleClick(event) {\n    if (this.pointerUpTarget === event.target) {\n      this.pointerUpTarget = null;\n      return;\n    }\n    this.handlePointerBasedSelection(event);\n  }\n  handlePointerup(event) {\n    this.handleTouchEnd();\n    if (!this.shouldSupportDragAndSelect) {\n      return;\n    }\n    this.pointerUpTarget = event.target;\n    this.handlePointerBasedSelection(event);\n  }\n  async handlePointerBasedSelection(event) {\n    var _a, _b;\n    if (event instanceof MouseEvent && event.button !== 0) {\n      return;\n    }\n    if (this.isScrolling) {\n      return;\n    }\n    const path = event.composedPath();\n    const target = path.find((el) => {\n      if (!(el instanceof Element)) {\n        return false;\n      }\n      return el.getAttribute(\"role\") === this.childRole;\n    });\n    if (event.defaultPrevented) {\n      const index = this.childItems.indexOf(target);\n      if (((_a = target == null ? void 0 : target.menuData) == null ? void 0 : _a.focusRoot) === this && index > -1) {\n        this.focusedItemIndex = index;\n      }\n      return;\n    }\n    if ((target == null ? void 0 : target.href) && target.href.length) {\n      this.dispatchEvent(\n        new Event(\"change\", {\n          bubbles: true,\n          composed: true\n        })\n      );\n      return;\n    } else if (((_b = target == null ? void 0 : target.menuData) == null ? void 0 : _b.selectionRoot) === this && this.childItems.length) {\n      event.preventDefault();\n      if (target.hasSubmenu || target.open) {\n        return;\n      }\n      this.selectOrToggleItem(target);\n    } else {\n      return;\n    }\n    this.prepareToCleanUp();\n  }\n  handleDescendentOverlayOpened(event) {\n    const target = event.composedPath()[0];\n    if (!target.overlayElement) {\n      return;\n    }\n    this.descendentOverlays.set(target.overlayElement, target.overlayElement);\n  }\n  handleDescendentOverlayClosed(event) {\n    const target = event.composedPath()[0];\n    if (!target.overlayElement) {\n      return;\n    }\n    this.descendentOverlays.delete(target.overlayElement);\n  }\n  /**\n   * given a menu item, returns the next focusable menu item before or after it;\n   * if no menu item is provided, returns the first focusable menu item\n   * @param menuItem {MenuItem}\n   * @param before {boolean} return the item before; default is false\n   * @returns {MenuItem}\n   */\n  getNeighboringFocusableElement(menuItem, before = false) {\n    var _a;\n    const diff = before ? -1 : 1;\n    const elements = ((_a = this.rovingTabindexController) == null ? void 0 : _a.elements) || [];\n    const index = menuItem ? elements.indexOf(menuItem) : -1;\n    let newIndex = Math.min(Math.max(0, index + diff), elements.length - 1);\n    while (!this.isFocusableElement(elements[newIndex]) && 0 < newIndex && newIndex < elements.length - 1) {\n      newIndex += diff;\n    }\n    return this.isFocusableElement(elements[newIndex]) ? elements[newIndex] : menuItem || elements[0];\n  }\n  async selectOrToggleItem(targetItem) {\n    var _a;\n    const resolvedSelects = this.resolvedSelects;\n    const oldSelectedItemsMap = new Map(this.selectedItemsMap);\n    const oldSelected = this.selected.slice();\n    const oldSelectedItems = this.selectedItems.slice();\n    const oldValue = this.value;\n    if (targetItem.menuData.selectionRoot !== this) {\n      return;\n    }\n    if (resolvedSelects === \"multiple\") {\n      if (this.selectedItemsMap.has(targetItem)) {\n        this.selectedItemsMap.delete(targetItem);\n      } else {\n        this.selectedItemsMap.set(targetItem, true);\n      }\n      const selected = [];\n      const selectedItems = [];\n      this.childItemSet.forEach((childItem) => {\n        if (childItem.menuData.selectionRoot !== this) {\n          return;\n        }\n        if (this.selectedItemsMap.has(childItem)) {\n          selected.push(childItem.value);\n          selectedItems.push(childItem);\n        }\n      });\n      this._selected = selected;\n      this.selectedItems = selectedItems;\n      this.value = this.selected.join(this.valueSeparator);\n    } else {\n      this.selectedItemsMap.clear();\n      this.selectedItemsMap.set(targetItem, true);\n      this.value = targetItem.value;\n      this._selected = [targetItem.value];\n      this.selectedItems = [targetItem];\n    }\n    const applyDefault = this.dispatchEvent(\n      new Event(\"change\", {\n        cancelable: true,\n        bubbles: true,\n        composed: true\n      })\n    );\n    if (!applyDefault) {\n      this._selected = oldSelected;\n      this.selectedItems = oldSelectedItems;\n      this.selectedItemsMap = oldSelectedItemsMap;\n      this.value = oldValue;\n      return;\n    }\n    if (resolvedSelects === \"single\") {\n      for (const oldItem of oldSelectedItemsMap.keys()) {\n        if (oldItem !== targetItem) {\n          oldItem.selected = false;\n        }\n      }\n      targetItem.selected = true;\n    } else if (resolvedSelects === \"multiple\") {\n      targetItem.selected = !targetItem.selected;\n    } else if (!targetItem.hasSubmenu && ((_a = targetItem == null ? void 0 : targetItem.menuData) == null ? void 0 : _a.focusRoot) === this) {\n      this.dispatchEvent(new Event(\"close\", { bubbles: true }));\n    }\n  }\n  navigateBetweenRelatedMenus(event) {\n    const { key, root } = event;\n    const dir = this.dir;\n    const shouldOpenSubmenu = dir === \"ltr\" && key === \"ArrowRight\" || dir === \"rtl\" && key === \"ArrowLeft\";\n    const shouldCloseSelfAsSubmenu = dir === \"ltr\" && key === \"ArrowLeft\" || dir === \"rtl\" && key === \"ArrowRight\" || key === \"Escape\";\n    const lastFocusedItem = root;\n    if (shouldOpenSubmenu) {\n      if (lastFocusedItem == null ? void 0 : lastFocusedItem.hasSubmenu) {\n        event.stopPropagation();\n        lastFocusedItem.openOverlay(true);\n      }\n    } else if (shouldCloseSelfAsSubmenu && this.isSubmenu) {\n      event.stopPropagation();\n      this.dispatchEvent(new Event(\"close\", { bubbles: true }));\n      this.updateSelectedItemIndex();\n    }\n  }\n  handleKeydown(event) {\n    var _a;\n    if (event.defaultPrevented || !this.rovingTabindexController) {\n      return;\n    }\n    const { key, root, shiftKey, target } = event;\n    const openSubmenuKey = [\"Enter\", \" \"].includes(key);\n    if (shiftKey && target !== this && this.hasAttribute(\"tabindex\")) {\n      this.removeAttribute(\"tabindex\");\n      const replaceTabindex = (event2) => {\n        if (!event2.shiftKey && !this.hasAttribute(\"tabindex\")) {\n          document.removeEventListener(\"keyup\", replaceTabindex);\n          this.removeEventListener(\"focusout\", replaceTabindex);\n        }\n      };\n      document.addEventListener(\"keyup\", replaceTabindex);\n      this.addEventListener(\"focusout\", replaceTabindex);\n    }\n    if (key === \"Tab\") {\n      this.closeDescendentOverlays();\n      return;\n    }\n    if (openSubmenuKey && (root == null ? void 0 : root.hasSubmenu) && !root.open) {\n      event.preventDefault();\n      root.openOverlay(true);\n      return;\n    }\n    if (key === \" \" || key === \"Enter\") {\n      event.preventDefault();\n      (_a = root == null ? void 0 : root.focusElement) == null ? void 0 : _a.click();\n      if (root) {\n        this.selectOrToggleItem(root);\n      }\n      return;\n    }\n    this.navigateBetweenRelatedMenus(event);\n  }\n  /**\n   * on focus, removes focus from focus styling item, and updates the selected item index\n   */\n  prepareToCleanUp() {\n    document.addEventListener(\n      \"focusout\",\n      () => {\n        requestAnimationFrame(() => {\n          const focusedItem = this.focusInItem;\n          if (focusedItem) {\n            focusedItem.focused = false;\n          }\n        });\n      },\n      { once: true }\n    );\n  }\n  updateSelectedItemIndex() {\n    let firstOrFirstSelectedIndex = 0;\n    const selectedItemsMap = /* @__PURE__ */ new Map();\n    const selected = [];\n    const selectedItems = [];\n    let itemIndex = this.childItems.length;\n    while (itemIndex) {\n      itemIndex -= 1;\n      const childItem = this.childItems[itemIndex];\n      if (childItem.menuData.selectionRoot === this) {\n        if (childItem.selected || !this._hasUpdatedSelectedItemIndex && this.selected.includes(childItem.value)) {\n          firstOrFirstSelectedIndex = itemIndex;\n          selectedItemsMap.set(childItem, true);\n          selected.unshift(childItem.value);\n          selectedItems.unshift(childItem);\n        }\n        if (itemIndex !== firstOrFirstSelectedIndex) {\n          childItem.focused = false;\n        }\n      }\n    }\n    this.selectedItemsMap = selectedItemsMap;\n    this._selected = selected;\n    this.selectedItems = selectedItems;\n    this.value = this.selected.join(this.valueSeparator);\n    this.focusedItemIndex = firstOrFirstSelectedIndex;\n    this.focusInItemIndex = firstOrFirstSelectedIndex;\n  }\n  handleItemsChanged() {\n    this.cachedChildItems = void 0;\n    if (!this._willUpdateItems) {\n      this._willUpdateItems = true;\n      this.cacheUpdated = this.updateCache();\n    }\n  }\n  async updateCache() {\n    if (!this.hasUpdated) {\n      await Promise.all([\n        new Promise((res) => requestAnimationFrame(() => res(true))),\n        this.updateComplete\n      ]);\n    } else {\n      await new Promise((res) => requestAnimationFrame(() => res(true)));\n    }\n    if (this.cachedChildItems === void 0) {\n      this.updateSelectedItemIndex();\n      this.updateItemFocus();\n    }\n    this._willUpdateItems = false;\n  }\n  updateItemFocus() {\n    var _a;\n    (_a = this.focusInItem) == null ? void 0 : _a.setAttribute(\"tabindex\", \"0\");\n    if (this.childItems.length == 0) {\n      return;\n    }\n  }\n  closeDescendentOverlays() {\n    this.descendentOverlays.forEach((overlay) => {\n      overlay.open = false;\n    });\n    this.descendentOverlays = /* @__PURE__ */ new Map();\n  }\n  handleSlotchange({\n    target\n  }) {\n    var _a;\n    const assignedElements = target.assignedElements({\n      flatten: true\n    });\n    if (this.childItems.length !== assignedElements.length) {\n      assignedElements.forEach((item) => {\n        if (typeof item.triggerUpdate !== \"undefined\") {\n          item.triggerUpdate();\n        } else if (typeof item.childItems !== \"undefined\") {\n          item.childItems.forEach((child) => {\n            child.triggerUpdate();\n          });\n        }\n      });\n    }\n    if (this._updateFocus) {\n      (_a = this.rovingTabindexController) == null ? void 0 : _a.focusOnItem(this._updateFocus);\n      this._updateFocus = void 0;\n    }\n  }\n  renderMenuItemSlot() {\n    return html`\n      <slot\n        @sp-menu-submenu-opened=${this.handleDescendentOverlayOpened}\n        @sp-menu-submenu-closed=${this.handleDescendentOverlayClosed}\n        @slotchange=${this.handleSlotchange}\n      ></slot>\n    `;\n  }\n  render() {\n    return this.renderMenuItemSlot();\n  }\n  firstUpdated(changed) {\n    super.firstUpdated(changed);\n    const updates = [\n      new Promise((res) => requestAnimationFrame(() => res(true)))\n    ];\n    [...this.children].forEach((item) => {\n      if (item.localName === \"sp-menu-item\") {\n        updates.push(item.updateComplete);\n      }\n    });\n    this.childItemsUpdated = Promise.all(updates);\n  }\n  updated(changes) {\n    super.updated(changes);\n    if (changes.has(\"selects\") && this.hasUpdated) {\n      this.selectsChanged();\n    }\n    if (changes.has(\"label\") && (this.label || typeof changes.get(\"label\") !== \"undefined\")) {\n      if (this.label) {\n        this.setAttribute(\"aria-label\", this.label);\n      } else {\n        this.removeAttribute(\"aria-label\");\n      }\n    }\n  }\n  selectsChanged() {\n    const updates = [\n      new Promise((res) => requestAnimationFrame(() => res(true)))\n    ];\n    this.childItemSet.forEach((childItem) => {\n      updates.push(childItem.triggerUpdate());\n    });\n    this.childItemsUpdated = Promise.all(updates);\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    if (!this.hasAttribute(\"role\") && !this.ignore) {\n      this.setAttribute(\"role\", this.ownRole);\n    }\n    this.updateComplete.then(() => this.updateItemFocus());\n  }\n  isFocusableElement(el) {\n    return el ? !el.disabled : false;\n  }\n  disconnectedCallback() {\n    this.cachedChildItems = void 0;\n    this.selectedItems = [];\n    this.selectedItemsMap.clear();\n    this.childItemSet.clear();\n    this.descendentOverlays = /* @__PURE__ */ new Map();\n    super.disconnectedCallback();\n  }\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    await this.childItemsUpdated;\n    await this.cacheUpdated;\n    return complete;\n  }\n}\nMenu.shadowRootOptions = {\n  ...SpectrumElement.shadowRootOptions,\n  delegatesFocus: true\n};\n__decorateClass([\n  property({ type: String, reflect: true })\n], Menu.prototype, \"label\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Menu.prototype, \"ignore\", 2);\n__decorateClass([\n  property({ type: String, reflect: true })\n], Menu.prototype, \"selects\", 2);\n__decorateClass([\n  property({ type: String })\n], Menu.prototype, \"value\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"value-separator\" })\n], Menu.prototype, \"valueSeparator\", 2);\n__decorateClass([\n  property({ attribute: false })\n], Menu.prototype, \"selected\", 1);\n__decorateClass([\n  property({ attribute: false })\n], Menu.prototype, \"selectedItems\", 2);\n__decorateClass([\n  query(\"slot:not([name])\")\n], Menu.prototype, \"menuSlot\", 2);\n//# sourceMappingURL=Menu.dev.js.map\n","\"use strict\";\nexport var InteractionTypes = /* @__PURE__ */ ((InteractionTypes2) => {\n  InteractionTypes2[InteractionTypes2[\"desktop\"] = 0] = \"desktop\";\n  InteractionTypes2[InteractionTypes2[\"mobile\"] = 1] = \"mobile\";\n  return InteractionTypes2;\n})(InteractionTypes || {});\nexport const SAFARI_FOCUS_RING_CLASS = \"remove-focus-ring-safari-hack\";\nexport class InteractionController {\n  /**\n   * Creates an interaction controller for the given host element.\n   * @param target - The trigger button element\n   * @param host - The host element this controller manages\n   */\n  constructor(target, host) {\n    this.target = target;\n    this.host = host;\n    /**\n     * Controls whether the next toggle action should be prevented.\n     * - `'no'`: Allow toggle\n     * - `'maybe'`: May prevent based on additional conditions\n     * - `'yes'`: Prevent the next toggle\n     */\n    this.preventNextToggle = \"no\";\n    /** Tracks the open state at the time of pointerdown for toggle logic. */\n    this.pointerdownState = false;\n    /** Tracks the target of an active Enter keydown to prevent double-activation. */\n    this.enterKeydownOn = null;\n    this._open = false;\n    this.target = target;\n    this.host = host;\n    this.host.addController(this);\n    this.init();\n  }\n  /**\n   * Indicates whether the host element is actively in the process of opening.\n   * Always returns false in the base class; may be overridden in subclasses.\n   */\n  get activelyOpening() {\n    return false;\n  }\n  /**\n   * Whether the host element overlay is currently open.\n   */\n  get open() {\n    return this._open;\n  }\n  /**\n   * Sets the open state and synchronizes with the host element.\n   * Also initializes the overlay reference if not already set.\n   */\n  set open(open) {\n    if (this._open === open) {\n      return;\n    }\n    this._open = open;\n    this.host.open = open;\n    if (!this.overlay && this.host.overlayElement) {\n      this.overlay = this.host.overlayElement;\n    }\n  }\n  /**\n   * Reference to the overlay element managing the host element's dropdown.\n   */\n  get overlay() {\n    return this._overlay;\n  }\n  /**\n   * Sets the overlay reference and initializes overlay configuration.\n   */\n  set overlay(overlay) {\n    if (!overlay) {\n      return;\n    }\n    if (this.overlay === overlay) {\n      return;\n    }\n    this._overlay = overlay;\n    this.initOverlay();\n  }\n  /**\n   * Releases any description resources.\n   * Override in subclasses if cleanup is needed.\n   */\n  releaseDescription() {\n  }\n  /**\n   * Initializes the overlay with appropriate configuration.\n   * Sets up event listeners, type, placement, and focus behavior.\n   */\n  initOverlay() {\n    if (this.overlay) {\n      this.overlay.type = this.host.isMobile.matches && !this.host.forcePopover ? \"modal\" : \"auto\";\n      this.overlay.triggerElement = this.host;\n      this.overlay.placement = this.host.isMobile.matches && !this.host.forcePopover ? void 0 : this.host.placement;\n      this.overlay.receivesFocus = \"false\";\n      this.overlay.willPreventClose = this.preventNextToggle !== \"no\" && this.open;\n      this.overlay.addEventListener(\n        \"slottable-request\",\n        this.host.handleSlottableRequest\n      );\n    }\n  }\n  /**\n   * Handles pointerdown events on the trigger button.\n   * Override in subclasses for device-specific behavior.\n   * @param _event - The pointer event\n   */\n  handlePointerdown(_event) {\n  }\n  /**\n   * Handles focus events on the trigger button.\n   * Prevents reopening the menu when focus returns from the menu itself.\n   * @param event - The focus event\n   */\n  handleButtonFocus(event) {\n    if (this.preventNextToggle === \"maybe\" && event.relatedTarget === this.host.optionsMenu) {\n      this.preventNextToggle = \"yes\";\n    }\n    if (this.preventNextToggle === \"no\") {\n      this.host.close();\n    }\n  }\n  /**\n   * Handles activation events (click, Enter, Space) on the trigger.\n   * Override in subclasses for device-specific behavior.\n   * @param _event - The activation event\n   */\n  handleActivate(_event) {\n  }\n  /**\n   * Initializes event listeners for the controller.\n   * Override in subclasses to bind device-specific events.\n   */\n  /* c8 ignore next 3 */\n  init() {\n  }\n  /**\n   * Cleans up the controller by releasing resources and aborting event listeners.\n   */\n  abort() {\n    var _a;\n    this.releaseDescription();\n    (_a = this.abortController) == null ? void 0 : _a.abort();\n  }\n  /**\n   * Lifecycle callback when the host element is connected to the DOM.\n   * Initializes event listeners.\n   */\n  hostConnected() {\n    this.init();\n  }\n  /**\n   * Lifecycle callback when the host element is disconnected from the DOM.\n   * Cleans up event listeners.\n   */\n  hostDisconnected() {\n    var _a;\n    (_a = this.abortController) == null ? void 0 : _a.abort();\n  }\n  /**\n   * Lifecycle callback after the host element updates.\n   * Ensures overlay reference is set and updates willPreventClose state.\n   */\n  hostUpdated() {\n    if (!this.overlay && this.host.overlayElement) {\n      this.overlay = this.host.overlayElement;\n    }\n    if (this.overlay && this.host.dependencyManager.loaded) {\n      this.overlay.willPreventClose = this.preventNextToggle !== \"no\";\n    }\n  }\n}\n//# sourceMappingURL=InteractionController.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing,\n  SizedMixin,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query,\n  state\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport {\n  classMap,\n  ifDefined,\n  styleMap\n} from \"@spectrum-web-components/base/src/directives.js\";\nimport chevronStyles from \"@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js\";\nimport { DependencyManagerController } from \"@spectrum-web-components/reactive-controllers/src/DependencyManger.js\";\nimport {\n  IS_MOBILE,\n  IS_TOUCH_DEVICE,\n  MatchMediaController\n} from \"@spectrum-web-components/reactive-controllers/src/MatchMedia.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js\";\nimport \"@spectrum-web-components/icons-workflow/icons/sp-icon-alert.js\";\nimport \"@spectrum-web-components/menu/sp-menu.js\";\nimport pickerStyles from \"./picker.css.js\";\nimport { strategies } from \"./strategies.dev.js\";\nconst chevronClass = {\n  s: \"spectrum-UIIcon-ChevronDown75\",\n  m: \"spectrum-UIIcon-ChevronDown100\",\n  l: \"spectrum-UIIcon-ChevronDown200\",\n  xl: \"spectrum-UIIcon-ChevronDown300\"\n};\nexport const DESCRIPTION_ID = \"option-picker\";\nexport class ExpandableElement extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    /** Controller that tracks whether the device is mobile. */\n    this.isMobile = new MatchMediaController(this, IS_MOBILE);\n    /** Controller that tracks whether the device supports touch input. */\n    this.isTouchDevice = new MatchMediaController(this, IS_TOUCH_DEVICE);\n    /** Controller that manages lazy-loading of overlay dependencies. */\n    this.dependencyManager = new DependencyManagerController(this);\n    this.disabled = false;\n    this.focused = false;\n    this.readonly = false;\n    this.pending = false;\n    this.forcePopover = false;\n    this.open = false;\n    this.placement = \"bottom-start\";\n    /**\n     * Handles slottable request events from the overlay.\n     * Override in subclasses to customize slottable behavior.\n     * @param _event - The slottable request event\n     */\n    this.handleSlottableRequest = (_event) => {\n    };\n    /**\n     * Handles the overlay's beforetoggle event.\n     * Manages overlay state and prevents unwanted closures during interaction.\n     * @param event - The beforetoggle event with the new state\n     */\n    this.handleBeforetoggle = (event) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n      if (event.composedPath()[0] !== event.target) {\n        return;\n      }\n      if (event.newState === \"closed\") {\n        const shouldRestoreFocus = ((_a = this.optionsMenu) == null ? void 0 : _a.matches(\":focus-within\")) && !((_b = this.button) == null ? void 0 : _b.matches(\":focus\"));\n        if (!this.open) {\n          if (this.strategy) {\n            this.strategy.open = false;\n          }\n        } else if (((_c = this.strategy) == null ? void 0 : _c.preventNextToggle) === \"no\") {\n          this.open = false;\n        } else if (!((_d = this.strategy) == null ? void 0 : _d.pointerdownState)) {\n          (_e = this.overlayElement) == null ? void 0 : _e.manuallyKeepOpen();\n        }\n        if (shouldRestoreFocus && !this.open) {\n          (_f = this.button) == null ? void 0 : _f.focus();\n        }\n      }\n      if (!this.open) {\n        (_g = this.optionsMenu) == null ? void 0 : _g.updateSelectedItemIndex();\n        (_h = this.optionsMenu) == null ? void 0 : _h.closeDescendentOverlays();\n      }\n    };\n  }\n  /**\n   * Returns the element that should receive focus.\n   * When open, returns the options menu; otherwise returns the trigger button.\n   */\n  get focusElement() {\n    if (this.open) {\n      return this.optionsMenu;\n    }\n    return this.button;\n  }\n  /**\n   * Focuses the appropriate element (button or menu) based on the picker's state.\n   * @param options - Standard focus options\n   */\n  focus(options) {\n    var _a;\n    (_a = this.focusElement) == null ? void 0 : _a.focus(options);\n  }\n  /**\n   * Closes the component's overlay.\n   * Has no effect when the component is readonly.\n   */\n  close() {\n    if (this.readonly) {\n      return;\n    }\n    if (this.strategy) {\n      this.open = false;\n      this.strategy.open = false;\n    }\n  }\n  /**\n   * Toggles the component's open state.\n   * Has no effect when the component is readonly, pending, or disabled.\n   * @param target - Optional explicit open state. If not provided, toggles the current state.\n   */\n  toggle(target) {\n    if (this.readonly || this.pending || this.disabled) {\n      return;\n    }\n    const open = typeof target !== \"undefined\" ? target : !this.open;\n    this.open = open;\n    if (this.strategy) {\n      this.strategy.open = this.open;\n    }\n  }\n  /**\n   * Binds the appropriate interaction strategy (desktop or mobile) based on device type.\n   * Aborts any existing strategy before creating a new one.\n   */\n  bindEvents() {\n    var _a;\n    (_a = this.strategy) == null ? void 0 : _a.abort();\n    if (this.isMobile.matches) {\n      this.strategy = new strategies[\"mobile\"](\n        this.button,\n        this\n      );\n    } else {\n      this.strategy = new strategies[\"desktop\"](\n        this.button,\n        this\n      );\n    }\n  }\n  /**\n   * Lifecycle callback when the element is disconnected from the DOM.\n   * Closes the overlay and releases strategy resources.\n   */\n  disconnectedCallback() {\n    var _a;\n    this.close();\n    (_a = this.strategy) == null ? void 0 : _a.releaseDescription();\n    super.disconnectedCallback();\n  }\n}\n/**\n * Shadow root configuration with delegatesFocus enabled.\n * Allows focus to be delegated to focusable children within the shadow root.\n */\nExpandableElement.shadowRootOptions = {\n  ...SpectrumElement.shadowRootOptions,\n  delegatesFocus: true\n};\n__decorateClass([\n  query(\"#button\")\n], ExpandableElement.prototype, \"button\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ExpandableElement.prototype, \"disabled\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ExpandableElement.prototype, \"focused\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ExpandableElement.prototype, \"readonly\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ExpandableElement.prototype, \"pending\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true, attribute: \"force-popover\" })\n], ExpandableElement.prototype, \"forcePopover\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ExpandableElement.prototype, \"open\", 2);\n__decorateClass([\n  query(\"sp-menu\")\n], ExpandableElement.prototype, \"optionsMenu\", 2);\n__decorateClass([\n  query(\"sp-overlay\")\n], ExpandableElement.prototype, \"overlayElement\", 2);\n__decorateClass([\n  property()\n], ExpandableElement.prototype, \"placement\", 2);\nexport class PickerBase extends SizedMixin(ExpandableElement, {\n  noDefaultSize: true\n}) {\n  constructor() {\n    super(...arguments);\n    this.deprecatedMenu = null;\n    this.invalid = false;\n    this.pendingLabel = \"Pending\";\n    /**\n     * The selection mode for the picker's menu.\n     * Always forced to `'single'` for standard picker behavior.\n     */\n    this.selects = \"single\";\n    this.quiet = false;\n    this.value = \"\";\n    /** The ARIA role for the menu list element. */\n    this.listRole = \"listbox\";\n    /** The ARIA role for individual menu items. */\n    this.itemRole = \"option\";\n    /**\n     * Handles Escape key press to close the picker overlay.\n     * @param event - The keyboard event\n     */\n    this.handleEscape = (event) => {\n      if (event.key === \"Escape\" && this.open) {\n        event.stopPropagation();\n        event.preventDefault();\n        this.toggle(false);\n      }\n    };\n    /**\n     * Handles keyboard navigation on the picker button.\n     * Opens the menu on Arrow keys, Enter, or Space.\n     * @param event - The keyboard event\n     */\n    this.handleKeydown = (event) => {\n      this.focused = true;\n      if (![\"ArrowUp\", \"ArrowDown\", \"Enter\", \" \", \"Escape\"].includes(event.key)) {\n        return;\n      }\n      if (event.key === \"Escape\") {\n        this.handleEscape(event);\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      this.keyboardOpen();\n    };\n    /**\n     * Callback invoked by an associated field label to apply its label value.\n     * Sets the applied label and determines label alignment based on the field label's configuration.\n     * @param value - The label text value\n     * @param labelElement - The field label element providing the label\n     */\n    this.applyFocusElementLabel = (value, labelElement) => {\n      this.appliedLabel = value;\n      this.labelAlignment = labelElement.sideAligned ? \"inline\" : void 0;\n    };\n    /** Tracks whether the overlay has been rendered at least once. */\n    this.hasRenderedOverlay = false;\n    /** Tracks whether a selection change is already scheduled for the next frame. */\n    this.willManageSelection = false;\n    this.selectionPromise = Promise.resolve();\n    this.recentlyConnected = false;\n    /** Tracks the target of an active Enter keydown to prevent double-activation. */\n    this.enterKeydownOn = null;\n    /**\n     * Handles Enter key events to prevent double-activation of menu items.\n     * Tracks keydown state and clears it on keyup.\n     * Also prevents Enter from triggering submenus that aren't open.\n     * @param event - The keyboard event\n     */\n    this.handleEnterKeydown = (event) => {\n      if (event.key !== \"Enter\") {\n        return;\n      }\n      const target = event == null ? void 0 : event.target;\n      if (!target.open && target.hasSubmenu) {\n        event.preventDefault();\n        return;\n      }\n      if (this.enterKeydownOn) {\n        event.preventDefault();\n        return;\n      }\n      this.enterKeydownOn = event.target;\n      this.addEventListener(\n        \"keyup\",\n        async (keyupEvent) => {\n          if (keyupEvent.key !== \"Enter\") {\n            return;\n          }\n          this.enterKeydownOn = null;\n        },\n        { once: true }\n      );\n    };\n  }\n  /**\n   * Returns the list of menu items contained in the picker's options menu.\n   */\n  get menuItems() {\n    return this.optionsMenu.childItems;\n  }\n  /**\n   * @deprecated This property always returns true and will be removed in a future version.\n   */\n  get selfManageFocusElement() {\n    return true;\n  }\n  get selectedItem() {\n    return this._selectedItem;\n  }\n  set selectedItem(selectedItem) {\n    this.selectedItemContent = selectedItem ? selectedItem.itemChildren : void 0;\n    if (selectedItem === this.selectedItem) {\n      return;\n    }\n    const oldSelectedItem = this.selectedItem;\n    this._selectedItem = selectedItem;\n    this.requestUpdate(\"selectedItem\", oldSelectedItem);\n  }\n  /**\n   * Programmatically applies visible focus styling to the picker.\n   * Has no effect when the picker is disabled.\n   */\n  forceFocusVisible() {\n    if (this.disabled) {\n      return;\n    }\n    this.focused = true;\n  }\n  /**\n   * Toggles the picker's open state when called programmatically.\n   * Note: Pointer events are handled by the interaction controller.\n   */\n  click() {\n    this.toggle();\n  }\n  /**\n   * Handles click events on the trigger button.\n   * Note: Pointer events are typically handled by the interaction controller;\n   * this method is called when `this.button.click()` is invoked programmatically.\n   */\n  handleButtonClick() {\n    if (this.disabled) {\n      return;\n    }\n    this.toggle();\n  }\n  /**\n   * Handles blur events on the trigger button, removing focus styling.\n   */\n  handleButtonBlur() {\n    this.focused = false;\n  }\n  /**\n   * @deprecated Use `focus()` instead.\n   * Focuses the picker button and applies focus styling.\n   */\n  handleHelperFocus() {\n    this.focused = true;\n    this.button.focus();\n  }\n  /**\n   * Handles focus events on the picker, applying visible focus styling\n   * only when focus is visible in the tree.\n   */\n  handleFocus() {\n    if (!this.disabled && this.focusElement) {\n      this.focused = this.hasVisibleFocusInTree();\n    }\n  }\n  /**\n   * Handles change events from the menu, updating the selected value.\n   * Dispatches a `change` event that can be prevented to cancel the selection.\n   * @param event - The change event from the menu\n   */\n  handleChange(event) {\n    if (this.strategy) {\n      this.strategy.preventNextToggle = \"no\";\n    }\n    const target = event.target;\n    const [selected] = target.selectedItems;\n    event.stopPropagation();\n    if (event.cancelable) {\n      this.setValueFromItem(selected, event);\n    } else {\n      this.open = false;\n      if (this.strategy) {\n        this.strategy.open = false;\n      }\n    }\n  }\n  /**\n   * Handles focus events on the trigger button, delegating to the interaction strategy.\n   * @param event - The focus event\n   */\n  handleButtonFocus(event) {\n    var _a;\n    (_a = this.strategy) == null ? void 0 : _a.handleButtonFocus(event);\n  }\n  /**\n   * Opens the picker via keyboard interaction and focuses the first selected item.\n   * If already open, focuses the first selected item in the menu.\n   */\n  async keyboardOpen() {\n    var _a;\n    if (!this.open || !this.strategy.open) {\n      this.addEventListener(\n        \"sp-opened\",\n        () => {\n          var _a2;\n          return (_a2 = this.optionsMenu) == null ? void 0 : _a2.focusOnFirstSelectedItem();\n        },\n        {\n          once: true\n        }\n      );\n      this.toggle(true);\n    } else {\n      (_a = this.optionsMenu) == null ? void 0 : _a.focusOnFirstSelectedItem();\n    }\n  }\n  /**\n   * Sets the picker's value from a menu item selection.\n   * Dispatches a cancelable `change` event and reverts the selection if prevented.\n   * @param item - The menu item to select\n   * @param menuChangeEvent - The original menu change event, if any\n   */\n  async setValueFromItem(item, menuChangeEvent) {\n    var _a;\n    this.open = false;\n    const oldSelectedItem = this.selectedItem;\n    const oldValue = this.value;\n    this.selectedItem = item;\n    this.value = (_a = item == null ? void 0 : item.value) != null ? _a : \"\";\n    await this.updateComplete;\n    const applyDefault = this.dispatchEvent(\n      new Event(\"change\", {\n        bubbles: true,\n        // Allow it to be prevented.\n        cancelable: true,\n        composed: true\n      })\n    );\n    if (!applyDefault && this.selects) {\n      if (menuChangeEvent) {\n        menuChangeEvent.preventDefault();\n      }\n      this.setMenuItemSelected(this.selectedItem, false);\n      if (oldSelectedItem) {\n        this.setMenuItemSelected(oldSelectedItem, true);\n      }\n      this.selectedItem = oldSelectedItem;\n      this.value = oldValue;\n      this.open = true;\n      if (this.strategy) {\n        this.strategy.open = true;\n      }\n      return;\n    } else if (!this.selects) {\n      this.selectedItem = oldSelectedItem;\n      this.value = oldValue;\n      return;\n    }\n    if (oldSelectedItem) {\n      this.setMenuItemSelected(oldSelectedItem, false);\n    }\n    this.setMenuItemSelected(item, !!this.selects);\n  }\n  /**\n   * Updates the selected state of a menu item.\n   * @param item - The menu item to update\n   * @param value - Whether the item should be selected\n   */\n  setMenuItemSelected(item, value) {\n    if (this.selects == null) {\n      return;\n    }\n    item.selected = value;\n  }\n  /**\n   * Returns inline styles for the overlay container.\n   * On mobile, sets full width; on desktop, returns empty styles.\n   */\n  get containerStyles() {\n    if (this.isMobile.matches) {\n      return {\n        \"--swc-menu-width\": \"100%\"\n      };\n    }\n    return {};\n  }\n  get selectedItemContent() {\n    return this._selectedItemContent || { icon: [], content: [] };\n  }\n  set selectedItemContent(selectedItemContent) {\n    if (selectedItemContent === this.selectedItemContent) {\n      return;\n    }\n    const oldContent = this.selectedItemContent;\n    this._selectedItemContent = selectedItemContent;\n    this.requestUpdate(\"selectedItemContent\", oldContent);\n  }\n  /**\n   * Handles slotchange events for the tooltip slot.\n   * Sets up the trigger element for self-managed tooltips.\n   * @param event - The slotchange event\n   */\n  handleTooltipSlotchange(event) {\n    var _a;\n    this.tooltipEl = event.target.assignedElements()[0];\n    if ((_a = this.tooltipEl) == null ? void 0 : _a.selfManaged) {\n      this.updateComplete.then(() => {\n        var _a2;\n        if (((_a2 = this.tooltipEl) == null ? void 0 : _a2.overlayElement) && this.button) {\n          this.tooltipEl.overlayElement.triggerElement = this.button;\n        }\n      });\n    }\n  }\n  /**\n   * Renders the label content for the picker button.\n   * Shows the selected item's content if available, otherwise renders the placeholder label.\n   * @param content - The content nodes from the selected item\n   * @returns The rendered label content\n   */\n  renderLabelContent(content) {\n    if (this.value && this.selectedItem) {\n      return content;\n    }\n    return html`\n      <slot name=\"label\" id=\"label\">\n        <span aria-hidden=${ifDefined(this.appliedLabel ? void 0 : \"true\")}>\n          ${this.label}\n        </span>\n      </slot>\n    `;\n  }\n  /**\n   * Renders the loading indicator shown during pending state.\n   * Dynamically imports the progress-circle component.\n   * @returns The rendered progress circle template\n   */\n  renderLoader() {\n    import(\"@spectrum-web-components/progress-circle/sp-progress-circle.js\");\n    return html`\n      <sp-progress-circle\n        size=\"s\"\n        indeterminate\n        role=\"presentation\"\n        class=\"progress-circle\"\n      ></sp-progress-circle>\n    `;\n  }\n  /**\n   * Returns the content to render inside the picker button,\n   * including the icon, label, validation icon, and chevron.\n   */\n  get buttonContent() {\n    const labelClasses = {\n      \"visually-hidden\": this.icons === \"only\" && !!this.value,\n      placeholder: !this.value,\n      label: true\n    };\n    const appliedLabel = this.appliedLabel || this.label;\n    return [\n      html`\n        <span id=\"icon\" ?hidden=${this.icons === \"none\"}>\n          ${this.selectedItemContent.icon}\n        </span>\n        <span\n          id=${ifDefined(this.value && this.selectedItem ? \"label\" : void 0)}\n          class=${classMap(labelClasses)}\n        >\n          ${this.renderLabelContent(this.selectedItemContent.content)}\n        </span>\n        ${this.value && this.selectedItem ? html`\n              <span\n                aria-hidden=\"true\"\n                class=\"visually-hidden\"\n                id=\"applied-label\"\n              >\n                ${appliedLabel}\n                <slot name=\"label\"></slot>\n              </span>\n            ` : html`\n              <span hidden id=\"applied-label\">${appliedLabel}</span>\n            `}\n        ${this.invalid && !this.pending ? html`\n              <sp-icon-alert class=\"validation-icon\"></sp-icon-alert>\n            ` : nothing}\n        ${this.pending ? html`\n              ${this.renderLoader()}\n              <span\n                aria-hidden=\"true\"\n                class=\"visually-hidden\"\n                id=\"pending-label\"\n              >\n                ${this.pendingLabel}\n              </span>\n            ` : nothing}\n        <sp-icon-chevron100\n          class=\"picker ${chevronClass[this.size]}\"\n        ></sp-icon-chevron100>\n      `\n    ];\n  }\n  /**\n   * Checks whether the picker has an accessible label through any supported method:\n   * - `label` attribute\n   * - `aria-label` attribute\n   * - `aria-labelledby` attribute\n   * - Applied label from a field label\n   * - Slotted label content\n   * @returns True if an accessible label is present\n   */\n  hasAccessibleLabel() {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const slotContent = ((_a = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _a.textContent) && ((_c = (_b = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _b.textContent) == null ? void 0 : _c.trim()) !== \"\";\n    const slotAlt = ((_e = (_d = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _d.getAttribute(\"alt\")) == null ? void 0 : _e.trim()) && ((_g = (_f = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _f.getAttribute(\"alt\")) == null ? void 0 : _g.trim()) !== \"\";\n    return !!this.label || !!this.getAttribute(\"aria-label\") || !!this.getAttribute(\"aria-labelledby\") || !!this.appliedLabel || !!slotContent || !!slotAlt;\n  }\n  /**\n   * Logs a warning in debug mode when the picker lacks an accessible label.\n   * Provides guidance on how to make the picker accessible.\n   */\n  warnNoLabel() {\n    if (true) {\n      window.__swc.warn(\n        this,\n        `<${this.localName}> needs one of the following to be accessible:`,\n        \"https://opensource.adobe.com/spectrum-web-components/components/picker/#accessibility\",\n        {\n          type: \"accessibility\",\n          issues: [\n            `an <sp-field-label> element with a \\`for\\` attribute referencing the \\`id\\` of the \\`<${this.localName}>\\`, or`,\n            'value supplied to the \"label\" attribute, which will be displayed visually as placeholder text, or',\n            'text content supplied in a <span> with slot=\"label\", which will also be displayed visually as placeholder text.'\n          ]\n        }\n      );\n    }\n  }\n  /**\n   * Renders the overlay element containing the menu.\n   * Configures the overlay with appropriate placement, type, and event handlers.\n   * @param menu - The menu template to render inside the overlay\n   * @returns The rendered overlay template\n   */\n  renderOverlay(menu) {\n    var _a;\n    const container = this.renderContainer(menu);\n    this.dependencyManager.add(\"sp-overlay\");\n    import(\"@spectrum-web-components/overlay/sp-overlay.js\");\n    return html`\n      <sp-overlay\n        @slottable-request=${this.handleSlottableRequest}\n        @beforetoggle=${this.handleBeforetoggle}\n        .triggerElement=${this}\n        .offset=${0}\n        ?open=${this.open && this.dependencyManager.loaded}\n        .placement=${this.isMobile.matches && !this.forcePopover ? void 0 : this.placement}\n        .type=${this.isMobile.matches && !this.forcePopover ? \"modal\" : \"auto\"}\n        .receivesFocus=${\"false\"}\n        .willPreventClose=${((_a = this.strategy) == null ? void 0 : _a.preventNextToggle) !== \"no\" && this.open && this.dependencyManager.loaded}\n      >\n        ${container}\n      </sp-overlay>\n    `;\n  }\n  /**\n   * Renders the description slot for additional picker context.\n   * Content is referenced by aria-describedby for accessibility.\n   */\n  get renderDescriptionSlot() {\n    return html`\n      <div id=${DESCRIPTION_ID}>\n        <slot name=\"description\"></slot>\n      </div>\n    `;\n  }\n  // a helper to throw focus to the button is needed because Safari\n  // won't include buttons in the tab order even with tabindex=\"0\"\n  render() {\n    if (this.tooltipEl) {\n      this.tooltipEl.disabled = this.open;\n    }\n    return html`\n      <button\n        aria-controls=${ifDefined(this.open ? \"menu\" : void 0)}\n        aria-describedby=\"tooltip ${DESCRIPTION_ID}\"\n        aria-expanded=${this.open ? \"true\" : \"false\"}\n        aria-haspopup=\"true\"\n        aria-labelledby=\"icon label applied-label pending-label\"\n        id=\"button\"\n        class=${ifDefined(\n      this.labelAlignment ? `label-${this.labelAlignment}` : void 0\n    )}\n        @focus=${this.handleButtonFocus}\n        @blur=${this.handleButtonBlur}\n        @keydown=${{\n      handleEvent: this.handleEnterKeydown,\n      capture: true\n    }}\n        ?disabled=${this.disabled}\n      >\n        ${this.buttonContent}\n      </button>\n      <slot\n        aria-hidden=\"true\"\n        name=\"tooltip\"\n        id=\"tooltip\"\n        @keydown=${this.handleKeydown}\n        @slotchange=${this.handleTooltipSlotchange}\n      ></slot>\n      ${this.renderMenu} ${this.renderDescriptionSlot}\n    `;\n  }\n  willUpdate(changes) {\n    super.willUpdate(changes);\n    if (changes.has(\"tabIndex\") && !!this.tabIndex) {\n      this.button.tabIndex = this.tabIndex;\n      this.removeAttribute(\"tabindex\");\n    }\n  }\n  update(changes) {\n    var _a, _b;\n    if (this.selects) {\n      this.selects = \"single\";\n    }\n    if (changes.has(\"disabled\") && this.disabled) {\n      this.close();\n    }\n    if (changes.has(\"pending\") && this.pending) {\n      this.close();\n    }\n    if (changes.has(\"value\")) {\n      this.shouldScheduleManageSelection();\n    }\n    if (!this.hasUpdated) {\n      this.deprecatedMenu = this.querySelector(\":scope > sp-menu\");\n      (_a = this.deprecatedMenu) == null ? void 0 : _a.toggleAttribute(\"ignore\", true);\n      (_b = this.deprecatedMenu) == null ? void 0 : _b.setAttribute(\"selects\", \"inherit\");\n    }\n    if (true) {\n      if (!this.hasUpdated && this.querySelector(\":scope > sp-menu\")) {\n        const { localName } = this;\n        window.__swc.warn(\n          this,\n          `You no longer need to provide an <sp-menu> child to ${localName}. Any styling or attributes on the <sp-menu> will be ignored.`,\n          \"https://opensource.adobe.com/spectrum-web-components/components/picker/#sizes\",\n          { level: \"deprecation\" }\n        );\n      }\n      this.updateComplete.then(async () => {\n        await new Promise((res) => requestAnimationFrame(res));\n        await new Promise((res) => requestAnimationFrame(res));\n        if (!this.hasAccessibleLabel()) {\n          this.warnNoLabel();\n        }\n      });\n    }\n    super.update(changes);\n  }\n  /**\n   * Binds the keydown event listener to the trigger button.\n   * Called during first update to enable keyboard navigation.\n   */\n  bindButtonKeydownListener() {\n    this.button.addEventListener(\"keydown\", this.handleKeydown);\n  }\n  updated(changes) {\n    super.updated(changes);\n    if (changes.has(\"open\") && this.overlayElement && !this.strategy.overlay) {\n      this.strategy.overlay = this.overlayElement;\n    }\n  }\n  async firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.bindButtonKeydownListener();\n    this.bindEvents();\n    await this.updateComplete;\n    if (this.overlayElement && !this.strategy.overlay) {\n      this.strategy.overlay = this.overlayElement;\n    }\n  }\n  /**\n   * Renders a visually hidden dismiss button for accessibility.\n   * Allows screen reader users to dismiss the overlay.\n   */\n  get dismissHelper() {\n    return html`\n      <div class=\"visually-hidden\">\n        <button\n          tabindex=\"-1\"\n          aria-label=\"Dismiss\"\n          @click=${this.close}\n        ></button>\n      </div>\n    `;\n  }\n  /**\n   * Renders the overlay container (popover or tray) based on device type.\n   * On mobile, uses a tray; on desktop, uses a popover.\n   * @param menu - The menu template to wrap in the container\n   * @returns The rendered container template\n   */\n  renderContainer(menu) {\n    const accessibleMenu = html`\n      ${this.dismissHelper} ${menu} ${this.dismissHelper}\n    `;\n    if (this.isMobile.matches && !this.forcePopover) {\n      this.dependencyManager.add(\"sp-tray\");\n      import(\"@spectrum-web-components/tray/sp-tray.js\");\n      return html`\n        <sp-tray\n          id=\"popover\"\n          role=\"presentation\"\n          style=${styleMap(this.containerStyles)}\n        >\n          ${accessibleMenu}\n        </sp-tray>\n      `;\n    }\n    this.dependencyManager.add(\"sp-popover\");\n    import(\"@spectrum-web-components/popover/sp-popover.js\");\n    return html`\n      <sp-popover\n        id=\"popover\"\n        role=\"presentation\"\n        style=${styleMap(this.containerStyles)}\n        placement=${this.placement}\n      >\n        ${accessibleMenu}\n      </sp-popover>\n    `;\n  }\n  /**\n   * Dispatches a scroll event when the menu is scrolled.\n   * Allows parent components to react to menu scroll events.\n   */\n  onScroll() {\n    this.dispatchEvent(\n      new Event(\"scroll\", {\n        cancelable: true,\n        composed: true\n      })\n    );\n  }\n  /**\n   * Renders the menu and overlay structure.\n   * Lazily renders the overlay only after the picker has been focused or opened.\n   */\n  get renderMenu() {\n    const menu = html`\n      <sp-menu\n        aria-labelledby=\"applied-label\"\n        @change=${this.handleChange}\n        id=\"menu\"\n        @keydown=${{\n      handleEvent: this.handleEnterKeydown,\n      capture: true\n    }}\n        @scroll=${this.onScroll}\n        role=${this.listRole}\n        .selects=${this.selects}\n        .selected=${this.value ? [this.value] : []}\n        .shouldSupportDragAndSelect=${!this.isTouchDevice.matches}\n        size=${this.size}\n        @sp-menu-item-keydown=${this.handleEscape}\n        @sp-menu-item-added-or-updated=${this.shouldManageSelection}\n      >\n        <slot @slotchange=${this.shouldScheduleManageSelection}></slot>\n      </sp-menu>\n    `;\n    this.hasRenderedOverlay = this.hasRenderedOverlay || this.focused || this.open || !!this.deprecatedMenu;\n    if (this.hasRenderedOverlay) {\n      if (this.dependencyManager.loaded) {\n        this.dependencyManager.add(\"sp-overlay\");\n      }\n      return this.renderOverlay(menu);\n    }\n    return menu;\n  }\n  /**\n   * Schedules selection management for the next animation frame.\n   * Called when the value changes or menu slot content changes.\n   * Prevents duplicate scheduling if already pending.\n   * @param event - Optional event that triggered the scheduling\n   */\n  shouldScheduleManageSelection(event) {\n    if (!this.willManageSelection && (!event || event.target.getRootNode().host === this)) {\n      this.willManageSelection = true;\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          this.manageSelection();\n        });\n      });\n    }\n  }\n  /**\n   * Immediately manages selection when a menu item is added or updated.\n   * Skips if selection management is already scheduled.\n   */\n  shouldManageSelection() {\n    if (this.willManageSelection) {\n      return;\n    }\n    this.willManageSelection = true;\n    this.manageSelection();\n  }\n  /**\n   * Synchronizes the menu selection state with the picker's current value.\n   * Finds and selects the menu item matching the current value,\n   * and deselects all other items.\n   */\n  async manageSelection() {\n    if (this.selects == null) {\n      return;\n    }\n    this.selectionPromise = new Promise(\n      (res) => this.selectionResolver = res\n    );\n    let selectedItem;\n    await this.optionsMenu.updateComplete;\n    if (this.recentlyConnected) {\n      await new Promise((res) => requestAnimationFrame(() => res(true)));\n      this.recentlyConnected = false;\n    }\n    this.menuItems.forEach((item) => {\n      if (this.value === item.value && !item.disabled) {\n        selectedItem = item;\n      } else {\n        item.selected = false;\n      }\n    });\n    if (selectedItem) {\n      selectedItem.selected = !!this.selects;\n      this.selectedItem = selectedItem;\n    } else {\n      const hasItemsWithValues = this.menuItems.some(\n        (item) => {\n          var _a;\n          return item.value != null || ((_a = item.getAttribute) == null ? void 0 : _a.call(item, \"value\")) != null;\n        }\n      );\n      if (this.menuItems.length > 0 && hasItemsWithValues) {\n        this.value = \"\";\n        this.selectedItem = void 0;\n      }\n    }\n    if (this.open) {\n      await this.optionsMenu.updateComplete;\n      this.optionsMenu.updateSelectedItemIndex();\n    }\n    this.selectionResolver();\n    this.willManageSelection = false;\n  }\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    await this.selectionPromise;\n    return complete;\n  }\n  connectedCallback() {\n    if (true) {\n      window.__swc.warn(\n        this,\n        `PickerBase class is deprecated and will be removed in a future release. Use the ExpandableElement base class instead.`,\n        \"https://opensource.adobe.com/spectrum-web-components/components/picker/#deprecation\",\n        { level: \"deprecation\" }\n      );\n    }\n    super.connectedCallback();\n    this.updateComplete.then(() => {\n      var _a;\n      if (!((_a = this.tooltipEl) == null ? void 0 : _a.selfManaged)) {\n        return;\n      }\n      const overlayElement = this.tooltipEl.overlayElement;\n      if (overlayElement) {\n        overlayElement.triggerElement = this.button;\n      }\n    });\n    this.recentlyConnected = this.hasUpdated;\n    this.addEventListener(\"focus\", this.handleFocus);\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener(\"focus\", this.handleFocus);\n  }\n}\n__decorateClass([\n  state()\n], PickerBase.prototype, \"appliedLabel\", 2);\n__decorateClass([\n  property({ type: String, reflect: true })\n], PickerBase.prototype, \"icons\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], PickerBase.prototype, \"invalid\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"pending-label\" })\n], PickerBase.prototype, \"pendingLabel\", 2);\n__decorateClass([\n  property()\n], PickerBase.prototype, \"label\", 2);\n__decorateClass([\n  state()\n], PickerBase.prototype, \"labelAlignment\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], PickerBase.prototype, \"quiet\", 2);\n__decorateClass([\n  property({ type: String })\n], PickerBase.prototype, \"value\", 2);\n__decorateClass([\n  property({ attribute: false })\n], PickerBase.prototype, \"selectedItem\", 1);\n__decorateClass([\n  state()\n], PickerBase.prototype, \"selectedItemContent\", 1);\nexport class Picker extends SizedMixin(ExpandableElement, {\n  noDefaultSize: true\n}) {\n  constructor() {\n    super(...arguments);\n    this.deprecatedMenu = null;\n    this.invalid = false;\n    this.pendingLabel = \"Pending\";\n    /**\n     * The selection mode for the picker's menu.\n     * Always forced to `'single'` for standard picker behavior.\n     */\n    this.selects = \"single\";\n    this.quiet = false;\n    this.value = \"\";\n    /** The ARIA role for the menu list element. */\n    this.listRole = \"listbox\";\n    /** The ARIA role for individual menu items. */\n    this.itemRole = \"option\";\n    /**\n     * Handles Escape key press to close the picker overlay.\n     * @param event - The keyboard event\n     */\n    this.handleEscape = (event) => {\n      if (event.key === \"Escape\" && this.open) {\n        event.stopPropagation();\n        event.preventDefault();\n        this.toggle(false);\n      }\n    };\n    /**\n     * Enhanced keyboard handler that supports arrow key navigation to cycle\n     * through options without opening the menu (in addition to base navigation).\n     * @param event - The keyboard event\n     */\n    this.handleKeydown = (event) => {\n      var _a;\n      const { key } = event;\n      const handledKeys = [\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"Enter\",\n        \" \",\n        \"Escape\"\n      ].includes(key);\n      const openKeys = [\"ArrowUp\", \"ArrowDown\", \"Enter\", \" \"].includes(key);\n      const arrowKeys = [\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"ArrowLeft\",\n        \"ArrowRight\"\n      ].includes(key);\n      this.focused = true;\n      if (\"Escape\" === key) {\n        this.handleEscape(event);\n        return;\n      }\n      if (!handledKeys || this.readonly || this.pending) {\n        return;\n      }\n      if (openKeys) {\n        this.keyboardOpen();\n        event.preventDefault();\n        if (arrowKeys) {\n          event.stopPropagation();\n        }\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      const nextItem = (_a = this.optionsMenu) == null ? void 0 : _a.getNeighboringFocusableElement(\n        this.selectedItem,\n        key === \"ArrowLeft\"\n      );\n      if (!this.value || nextItem !== this.selectedItem) {\n        if (nextItem) {\n          this.setValueFromItem(nextItem);\n        }\n      }\n    };\n    /**\n     * Callback invoked by an associated field label to apply its label value.\n     * Sets the applied label and determines label alignment based on the field label's configuration.\n     * @param value - The label text value\n     * @param labelElement - The field label element providing the label\n     */\n    this.applyFocusElementLabel = (value, labelElement) => {\n      this.appliedLabel = value;\n      this.labelAlignment = labelElement.sideAligned ? \"inline\" : void 0;\n    };\n    /** Tracks whether the overlay has been rendered at least once. */\n    this.hasRenderedOverlay = false;\n    /** Tracks whether a selection change is already scheduled for the next frame. */\n    this.willManageSelection = false;\n    this.selectionPromise = Promise.resolve();\n    this.recentlyConnected = false;\n    /** Tracks the target of an active Enter keydown to prevent double-activation. */\n    this.enterKeydownOn = null;\n    /**\n     * Handles Enter key events to prevent double-activation of menu items.\n     * Tracks keydown state and clears it on keyup.\n     * Also prevents Enter from triggering submenus that aren't open.\n     * @param event - The keyboard event\n     */\n    this.handleEnterKeydown = (event) => {\n      if (event.key !== \"Enter\") {\n        return;\n      }\n      const target = event == null ? void 0 : event.target;\n      if (!target.open && target.hasSubmenu) {\n        event.preventDefault();\n        return;\n      }\n      if (this.enterKeydownOn) {\n        event.preventDefault();\n        return;\n      }\n      this.enterKeydownOn = event.target;\n      this.addEventListener(\n        \"keyup\",\n        async (keyupEvent) => {\n          if (keyupEvent.key !== \"Enter\") {\n            return;\n          }\n          this.enterKeydownOn = null;\n        },\n        { once: true }\n      );\n    };\n  }\n  static get styles() {\n    return [pickerStyles, chevronStyles];\n  }\n  /**\n   * Returns the list of menu items contained in the picker's options menu.\n   */\n  get menuItems() {\n    return this.optionsMenu.childItems;\n  }\n  /**\n   * @deprecated This property always returns true and will be removed in a future version.\n   */\n  get selfManageFocusElement() {\n    return true;\n  }\n  get selectedItem() {\n    return this._selectedItem;\n  }\n  set selectedItem(selectedItem) {\n    this.selectedItemContent = selectedItem ? selectedItem.itemChildren : void 0;\n    if (selectedItem === this.selectedItem) {\n      return;\n    }\n    const oldSelectedItem = this.selectedItem;\n    this._selectedItem = selectedItem;\n    this.requestUpdate(\"selectedItem\", oldSelectedItem);\n  }\n  /**\n   * Programmatically applies visible focus styling to the picker.\n   * Has no effect when the picker is disabled.\n   */\n  forceFocusVisible() {\n    if (this.disabled) {\n      return;\n    }\n    this.focused = true;\n  }\n  /**\n   * Toggles the picker's open state when called programmatically.\n   * Note: Pointer events are handled by the interaction controller.\n   */\n  click() {\n    this.toggle();\n  }\n  /**\n   * Handles click events on the trigger button.\n   * Note: Pointer events are typically handled by the interaction controller;\n   * this method is called when `this.button.click()` is invoked programmatically.\n   */\n  handleButtonClick() {\n    if (this.disabled) {\n      return;\n    }\n    this.toggle();\n  }\n  /**\n   * Handles blur events on the trigger button, removing focus styling.\n   */\n  handleButtonBlur() {\n    this.focused = false;\n  }\n  /**\n   * @deprecated Use `focus()` instead.\n   * Focuses the picker button and applies focus styling.\n   */\n  handleHelperFocus() {\n    this.focused = true;\n    this.button.focus();\n  }\n  /**\n   * Handles focus events on the picker, applying visible focus styling\n   * only when focus is visible in the tree.\n   */\n  handleFocus() {\n    if (!this.disabled && this.focusElement) {\n      this.focused = this.hasVisibleFocusInTree();\n    }\n  }\n  /**\n   * Handles change events from the menu, updating the selected value.\n   * Dispatches a `change` event that can be prevented to cancel the selection.\n   * @param event - The change event from the menu\n   */\n  handleChange(event) {\n    if (this.strategy) {\n      this.strategy.preventNextToggle = \"no\";\n    }\n    const target = event.target;\n    const [selected] = target.selectedItems;\n    event.stopPropagation();\n    if (event.cancelable) {\n      this.setValueFromItem(selected, event);\n    } else {\n      this.open = false;\n      if (this.strategy) {\n        this.strategy.open = false;\n      }\n    }\n  }\n  /**\n   * Handles focus events on the trigger button, delegating to the interaction strategy.\n   * @param event - The focus event\n   */\n  handleButtonFocus(event) {\n    var _a;\n    (_a = this.strategy) == null ? void 0 : _a.handleButtonFocus(event);\n  }\n  /**\n   * Opens the picker via keyboard interaction and focuses the first selected item.\n   * If already open, focuses the first selected item in the menu.\n   */\n  async keyboardOpen() {\n    var _a;\n    if (!this.open || !this.strategy.open) {\n      this.addEventListener(\n        \"sp-opened\",\n        () => {\n          var _a2;\n          return (_a2 = this.optionsMenu) == null ? void 0 : _a2.focusOnFirstSelectedItem();\n        },\n        {\n          once: true\n        }\n      );\n      this.toggle(true);\n    } else {\n      (_a = this.optionsMenu) == null ? void 0 : _a.focusOnFirstSelectedItem();\n    }\n  }\n  /**\n   * Sets the picker's value from a menu item selection.\n   * Dispatches a cancelable `change` event and reverts the selection if prevented.\n   * @param item - The menu item to select\n   * @param menuChangeEvent - The original menu change event, if any\n   */\n  async setValueFromItem(item, menuChangeEvent) {\n    var _a;\n    this.open = false;\n    const oldSelectedItem = this.selectedItem;\n    const oldValue = this.value;\n    this.selectedItem = item;\n    this.value = (_a = item == null ? void 0 : item.value) != null ? _a : \"\";\n    await this.updateComplete;\n    const applyDefault = this.dispatchEvent(\n      new Event(\"change\", {\n        bubbles: true,\n        // Allow it to be prevented.\n        cancelable: true,\n        composed: true\n      })\n    );\n    if (!applyDefault && this.selects) {\n      if (menuChangeEvent) {\n        menuChangeEvent.preventDefault();\n      }\n      this.setMenuItemSelected(this.selectedItem, false);\n      if (oldSelectedItem) {\n        this.setMenuItemSelected(oldSelectedItem, true);\n      }\n      this.selectedItem = oldSelectedItem;\n      this.value = oldValue;\n      this.open = true;\n      if (this.strategy) {\n        this.strategy.open = true;\n      }\n      return;\n    } else if (!this.selects) {\n      this.selectedItem = oldSelectedItem;\n      this.value = oldValue;\n      return;\n    }\n    if (oldSelectedItem) {\n      this.setMenuItemSelected(oldSelectedItem, false);\n    }\n    this.setMenuItemSelected(item, !!this.selects);\n  }\n  /**\n   * Updates the selected state of a menu item.\n   * @param item - The menu item to update\n   * @param value - Whether the item should be selected\n   */\n  setMenuItemSelected(item, value) {\n    if (this.selects == null) {\n      return;\n    }\n    item.selected = value;\n  }\n  /**\n   * Returns inline styles for the overlay container.\n   * On mobile, sets full width; on desktop, returns empty styles.\n   */\n  get containerStyles() {\n    const styles = {};\n    if (!this.quiet) {\n      styles[\"min-width\"] = `${this.offsetWidth}px`;\n    }\n    if (this.isMobile.matches) {\n      styles[\"--swc-menu-width\"] = \"100%\";\n    }\n    return styles;\n  }\n  get selectedItemContent() {\n    return this._selectedItemContent || { icon: [], content: [] };\n  }\n  set selectedItemContent(selectedItemContent) {\n    if (selectedItemContent === this.selectedItemContent) {\n      return;\n    }\n    const oldContent = this.selectedItemContent;\n    this._selectedItemContent = selectedItemContent;\n    this.requestUpdate(\"selectedItemContent\", oldContent);\n  }\n  /**\n   * Handles slotchange events for the tooltip slot.\n   * Sets up the trigger element for self-managed tooltips.\n   * @param event - The slotchange event\n   */\n  handleTooltipSlotchange(event) {\n    var _a;\n    this.tooltipEl = event.target.assignedElements()[0];\n    if ((_a = this.tooltipEl) == null ? void 0 : _a.selfManaged) {\n      this.updateComplete.then(() => {\n        var _a2;\n        if (((_a2 = this.tooltipEl) == null ? void 0 : _a2.overlayElement) && this.button) {\n          this.tooltipEl.overlayElement.triggerElement = this.button;\n        }\n      });\n    }\n  }\n  /**\n   * Renders the label content for the picker button.\n   * Shows the selected item's content if available, otherwise renders the placeholder label.\n   * @param content - The content nodes from the selected item\n   * @returns The rendered label content\n   */\n  renderLabelContent(content) {\n    if (this.value && this.selectedItem) {\n      return content;\n    }\n    return html`\n      <slot name=\"label\" id=\"label\">\n        <span aria-hidden=${ifDefined(this.appliedLabel ? void 0 : \"true\")}>\n          ${this.label}\n        </span>\n      </slot>\n    `;\n  }\n  /**\n   * Renders the loading indicator shown during pending state.\n   * Dynamically imports the progress-circle component.\n   * @returns The rendered progress circle template\n   */\n  renderLoader() {\n    import(\"@spectrum-web-components/progress-circle/sp-progress-circle.js\");\n    return html`\n      <sp-progress-circle\n        size=\"s\"\n        indeterminate\n        role=\"presentation\"\n        class=\"progress-circle\"\n      ></sp-progress-circle>\n    `;\n  }\n  /**\n   * Returns the content to render inside the picker button,\n   * including the icon, label, validation icon, and chevron.\n   */\n  get buttonContent() {\n    const labelClasses = {\n      \"visually-hidden\": this.icons === \"only\" && !!this.value,\n      placeholder: !this.value,\n      label: true\n    };\n    const appliedLabel = this.appliedLabel || this.label;\n    return [\n      html`\n        <span id=\"icon\" ?hidden=${this.icons === \"none\"}>\n          ${this.selectedItemContent.icon}\n        </span>\n        <span\n          id=${ifDefined(this.value && this.selectedItem ? \"label\" : void 0)}\n          class=${classMap(labelClasses)}\n        >\n          ${this.renderLabelContent(this.selectedItemContent.content)}\n        </span>\n        ${this.value && this.selectedItem ? html`\n              <span\n                aria-hidden=\"true\"\n                class=\"visually-hidden\"\n                id=\"applied-label\"\n              >\n                ${appliedLabel}\n                <slot name=\"label\"></slot>\n              </span>\n            ` : html`\n              <span hidden id=\"applied-label\">${appliedLabel}</span>\n            `}\n        ${this.invalid && !this.pending ? html`\n              <sp-icon-alert class=\"validation-icon\"></sp-icon-alert>\n            ` : nothing}\n        ${this.pending ? html`\n              ${this.renderLoader()}\n              <span\n                aria-hidden=\"true\"\n                class=\"visually-hidden\"\n                id=\"pending-label\"\n              >\n                ${this.pendingLabel}\n              </span>\n            ` : nothing}\n        <sp-icon-chevron100\n          class=\"picker ${chevronClass[this.size]}\"\n        ></sp-icon-chevron100>\n      `\n    ];\n  }\n  /**\n   * Checks whether the picker has an accessible label through any supported method:\n   * - `label` attribute\n   * - `aria-label` attribute\n   * - `aria-labelledby` attribute\n   * - Applied label from a field label\n   * - Slotted label content\n   * @returns True if an accessible label is present\n   */\n  hasAccessibleLabel() {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const slotContent = ((_a = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _a.textContent) && ((_c = (_b = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _b.textContent) == null ? void 0 : _c.trim()) !== \"\";\n    const slotAlt = ((_e = (_d = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _d.getAttribute(\"alt\")) == null ? void 0 : _e.trim()) && ((_g = (_f = this.querySelector('[slot=\"label\"]')) == null ? void 0 : _f.getAttribute(\"alt\")) == null ? void 0 : _g.trim()) !== \"\";\n    return !!this.label || !!this.getAttribute(\"aria-label\") || !!this.getAttribute(\"aria-labelledby\") || !!this.appliedLabel || !!slotContent || !!slotAlt;\n  }\n  /**\n   * Logs a warning in debug mode when the picker lacks an accessible label.\n   * Provides guidance on how to make the picker accessible.\n   */\n  warnNoLabel() {\n    if (true) {\n      window.__swc.warn(\n        this,\n        `<${this.localName}> needs one of the following to be accessible:`,\n        \"https://opensource.adobe.com/spectrum-web-components/components/picker/#accessibility\",\n        {\n          type: \"accessibility\",\n          issues: [\n            `an <sp-field-label> element with a \\`for\\` attribute referencing the \\`id\\` of the \\`<${this.localName}>\\`, or`,\n            'value supplied to the \"label\" attribute, which will be displayed visually as placeholder text, or',\n            'text content supplied in a <span> with slot=\"label\", which will also be displayed visually as placeholder text.'\n          ]\n        }\n      );\n    }\n  }\n  /**\n   * Renders the overlay element containing the menu.\n   * Configures the overlay with appropriate placement, type, and event handlers.\n   * @param menu - The menu template to render inside the overlay\n   * @returns The rendered overlay template\n   */\n  renderOverlay(menu) {\n    var _a;\n    const container = this.renderContainer(menu);\n    this.dependencyManager.add(\"sp-overlay\");\n    import(\"@spectrum-web-components/overlay/sp-overlay.js\");\n    return html`\n      <sp-overlay\n        @slottable-request=${this.handleSlottableRequest}\n        @beforetoggle=${this.handleBeforetoggle}\n        .triggerElement=${this}\n        .offset=${0}\n        ?open=${this.open && this.dependencyManager.loaded}\n        .placement=${this.isMobile.matches && !this.forcePopover ? void 0 : this.placement}\n        .type=${this.isMobile.matches && !this.forcePopover ? \"modal\" : \"auto\"}\n        .receivesFocus=${\"false\"}\n        .willPreventClose=${((_a = this.strategy) == null ? void 0 : _a.preventNextToggle) !== \"no\" && this.open && this.dependencyManager.loaded}\n      >\n        ${container}\n      </sp-overlay>\n    `;\n  }\n  /**\n   * Renders the description slot for additional picker context.\n   * Content is referenced by aria-describedby for accessibility.\n   */\n  get renderDescriptionSlot() {\n    return html`\n      <div id=${DESCRIPTION_ID}>\n        <slot name=\"description\"></slot>\n      </div>\n    `;\n  }\n  // a helper to throw focus to the button is needed because Safari\n  // won't include buttons in the tab order even with tabindex=\"0\"\n  render() {\n    if (this.tooltipEl) {\n      this.tooltipEl.disabled = this.open;\n    }\n    return html`\n      <button\n        aria-controls=${ifDefined(this.open ? \"menu\" : void 0)}\n        aria-describedby=\"tooltip ${DESCRIPTION_ID}\"\n        aria-expanded=${this.open ? \"true\" : \"false\"}\n        aria-haspopup=\"true\"\n        aria-labelledby=\"icon label applied-label pending-label\"\n        id=\"button\"\n        class=${ifDefined(\n      this.labelAlignment ? `label-${this.labelAlignment}` : void 0\n    )}\n        @focus=${this.handleButtonFocus}\n        @blur=${this.handleButtonBlur}\n        @keydown=${{\n      handleEvent: this.handleEnterKeydown,\n      capture: true\n    }}\n        ?disabled=${this.disabled}\n      >\n        ${this.buttonContent}\n      </button>\n      <slot\n        aria-hidden=\"true\"\n        name=\"tooltip\"\n        id=\"tooltip\"\n        @keydown=${this.handleKeydown}\n        @slotchange=${this.handleTooltipSlotchange}\n      ></slot>\n      ${this.renderMenu} ${this.renderDescriptionSlot}\n    `;\n  }\n  willUpdate(changes) {\n    super.willUpdate(changes);\n    if (changes.has(\"tabIndex\") && !!this.tabIndex) {\n      this.button.tabIndex = this.tabIndex;\n      this.removeAttribute(\"tabindex\");\n    }\n  }\n  update(changes) {\n    var _a, _b;\n    if (this.selects) {\n      this.selects = \"single\";\n    }\n    if (changes.has(\"disabled\") && this.disabled) {\n      this.close();\n    }\n    if (changes.has(\"pending\") && this.pending) {\n      this.close();\n    }\n    if (changes.has(\"value\")) {\n      this.shouldScheduleManageSelection();\n    }\n    if (!this.hasUpdated) {\n      this.deprecatedMenu = this.querySelector(\":scope > sp-menu\");\n      (_a = this.deprecatedMenu) == null ? void 0 : _a.toggleAttribute(\"ignore\", true);\n      (_b = this.deprecatedMenu) == null ? void 0 : _b.setAttribute(\"selects\", \"inherit\");\n    }\n    if (true) {\n      if (!this.hasUpdated && this.querySelector(\":scope > sp-menu\")) {\n        const { localName } = this;\n        window.__swc.warn(\n          this,\n          `You no longer need to provide an <sp-menu> child to ${localName}. Any styling or attributes on the <sp-menu> will be ignored.`,\n          \"https://opensource.adobe.com/spectrum-web-components/components/picker/#sizes\",\n          { level: \"deprecation\" }\n        );\n      }\n      this.updateComplete.then(async () => {\n        await new Promise((res) => requestAnimationFrame(res));\n        await new Promise((res) => requestAnimationFrame(res));\n        if (!this.hasAccessibleLabel()) {\n          this.warnNoLabel();\n        }\n      });\n    }\n    super.update(changes);\n  }\n  /**\n   * Binds the keydown event listener to the trigger button.\n   * Called during first update to enable keyboard navigation.\n   */\n  bindButtonKeydownListener() {\n    this.button.addEventListener(\"keydown\", this.handleKeydown);\n  }\n  updated(changes) {\n    super.updated(changes);\n    if (changes.has(\"open\") && this.overlayElement && !this.strategy.overlay) {\n      this.strategy.overlay = this.overlayElement;\n    }\n  }\n  async firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.bindButtonKeydownListener();\n    this.bindEvents();\n    await this.updateComplete;\n    if (this.overlayElement && !this.strategy.overlay) {\n      this.strategy.overlay = this.overlayElement;\n    }\n  }\n  /**\n   * Renders a visually hidden dismiss button for accessibility.\n   * Allows screen reader users to dismiss the overlay.\n   */\n  get dismissHelper() {\n    return html`\n      <div class=\"visually-hidden\">\n        <button\n          tabindex=\"-1\"\n          aria-label=\"Dismiss\"\n          @click=${this.close}\n        ></button>\n      </div>\n    `;\n  }\n  /**\n   * Renders the overlay container (popover or tray) based on device type.\n   * On mobile, uses a tray; on desktop, uses a popover.\n   * @param menu - The menu template to wrap in the container\n   * @returns The rendered container template\n   */\n  renderContainer(menu) {\n    const accessibleMenu = html`\n      ${this.dismissHelper} ${menu} ${this.dismissHelper}\n    `;\n    if (this.isMobile.matches && !this.forcePopover) {\n      this.dependencyManager.add(\"sp-tray\");\n      import(\"@spectrum-web-components/tray/sp-tray.js\");\n      return html`\n        <sp-tray\n          id=\"popover\"\n          role=\"presentation\"\n          style=${styleMap(this.containerStyles)}\n        >\n          ${accessibleMenu}\n        </sp-tray>\n      `;\n    }\n    this.dependencyManager.add(\"sp-popover\");\n    import(\"@spectrum-web-components/popover/sp-popover.js\");\n    return html`\n      <sp-popover\n        id=\"popover\"\n        role=\"presentation\"\n        style=${styleMap(this.containerStyles)}\n        placement=${this.placement}\n      >\n        ${accessibleMenu}\n      </sp-popover>\n    `;\n  }\n  /**\n   * Dispatches a scroll event when the menu is scrolled.\n   * Allows parent components to react to menu scroll events.\n   */\n  onScroll() {\n    this.dispatchEvent(\n      new Event(\"scroll\", {\n        cancelable: true,\n        composed: true\n      })\n    );\n  }\n  /**\n   * Renders the menu and overlay structure.\n   * Lazily renders the overlay only after the picker has been focused or opened.\n   */\n  get renderMenu() {\n    const menu = html`\n      <sp-menu\n        aria-labelledby=\"applied-label\"\n        @change=${this.handleChange}\n        id=\"menu\"\n        @keydown=${{\n      handleEvent: this.handleEnterKeydown,\n      capture: true\n    }}\n        @scroll=${this.onScroll}\n        role=${this.listRole}\n        .selects=${this.selects}\n        .selected=${this.value ? [this.value] : []}\n        .shouldSupportDragAndSelect=${!this.isTouchDevice.matches}\n        size=${this.size}\n        @sp-menu-item-keydown=${this.handleEscape}\n        @sp-menu-item-added-or-updated=${this.shouldManageSelection}\n      >\n        <slot @slotchange=${this.shouldScheduleManageSelection}></slot>\n      </sp-menu>\n    `;\n    this.hasRenderedOverlay = this.hasRenderedOverlay || this.focused || this.open || !!this.deprecatedMenu;\n    if (this.hasRenderedOverlay) {\n      if (this.dependencyManager.loaded) {\n        this.dependencyManager.add(\"sp-overlay\");\n      }\n      return this.renderOverlay(menu);\n    }\n    return menu;\n  }\n  /**\n   * Schedules selection management for the next animation frame.\n   * Called when the value changes or menu slot content changes.\n   * Prevents duplicate scheduling if already pending.\n   * @param event - Optional event that triggered the scheduling\n   */\n  shouldScheduleManageSelection(event) {\n    if (!this.willManageSelection && (!event || event.target.getRootNode().host === this)) {\n      this.willManageSelection = true;\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          this.manageSelection();\n        });\n      });\n    }\n  }\n  /**\n   * Immediately manages selection when a menu item is added or updated.\n   * Skips if selection management is already scheduled.\n   */\n  shouldManageSelection() {\n    if (this.willManageSelection) {\n      return;\n    }\n    this.willManageSelection = true;\n    this.manageSelection();\n  }\n  /**\n   * Synchronizes the menu selection state with the picker's current value.\n   * Finds and selects the menu item matching the current value,\n   * and deselects all other items.\n   */\n  async manageSelection() {\n    if (this.selects == null) {\n      return;\n    }\n    this.selectionPromise = new Promise(\n      (res) => this.selectionResolver = res\n    );\n    let selectedItem;\n    await this.optionsMenu.updateComplete;\n    if (this.recentlyConnected) {\n      await new Promise((res) => requestAnimationFrame(() => res(true)));\n      this.recentlyConnected = false;\n    }\n    this.menuItems.forEach((item) => {\n      if (this.value === item.value && !item.disabled) {\n        selectedItem = item;\n      } else {\n        item.selected = false;\n      }\n    });\n    if (selectedItem) {\n      selectedItem.selected = !!this.selects;\n      this.selectedItem = selectedItem;\n    } else {\n      const hasItemsWithValues = this.menuItems.some(\n        (item) => {\n          var _a;\n          return item.value != null || ((_a = item.getAttribute) == null ? void 0 : _a.call(item, \"value\")) != null;\n        }\n      );\n      if (this.menuItems.length > 0 && hasItemsWithValues) {\n        this.value = \"\";\n        this.selectedItem = void 0;\n      }\n    }\n    if (this.open) {\n      await this.optionsMenu.updateComplete;\n      this.optionsMenu.updateSelectedItemIndex();\n    }\n    this.selectionResolver();\n    this.willManageSelection = false;\n  }\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    await this.selectionPromise;\n    return complete;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.updateComplete.then(() => {\n      var _a;\n      if (!((_a = this.tooltipEl) == null ? void 0 : _a.selfManaged)) {\n        return;\n      }\n      const overlayElement = this.tooltipEl.overlayElement;\n      if (overlayElement) {\n        overlayElement.triggerElement = this.button;\n      }\n    });\n    this.recentlyConnected = this.hasUpdated;\n    this.addEventListener(\"focus\", this.handleFocus);\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener(\"focus\", this.handleFocus);\n  }\n}\n__decorateClass([\n  state()\n], Picker.prototype, \"appliedLabel\", 2);\n__decorateClass([\n  property({ type: String, reflect: true })\n], Picker.prototype, \"icons\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Picker.prototype, \"invalid\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"pending-label\" })\n], Picker.prototype, \"pendingLabel\", 2);\n__decorateClass([\n  property()\n], Picker.prototype, \"label\", 2);\n__decorateClass([\n  state()\n], Picker.prototype, \"labelAlignment\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Picker.prototype, \"quiet\", 2);\n__decorateClass([\n  property({ type: String })\n], Picker.prototype, \"value\", 2);\n__decorateClass([\n  property({ attribute: false })\n], Picker.prototype, \"selectedItem\", 1);\n__decorateClass([\n  state()\n], Picker.prototype, \"selectedItemContent\", 1);\n//# sourceMappingURL=Picker.dev.js.map\n","\"use strict\";import{css as t}from\"@spectrum-web-components/base\";const a=t`\n    #switch:before{transition:background var(--spectrum-animation-duration-100,.13s)ease-in-out,border var(--spectrum-animation-duration-100,.13s)ease-in-out,box-shadow var(--spectrum-animation-duration-100,.13s)ease-in-out}\n`;export default a;\n//# sourceMappingURL=switch-legacy.css.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SizedMixin\n} from \"@spectrum-web-components/base\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { CheckboxBase } from \"@spectrum-web-components/checkbox/src/CheckboxBase.js\";\nimport switchStyles from \"./switch.css.js\";\nimport legacyStyles from \"./switch-legacy.css.js\";\nexport class Switch extends SizedMixin(CheckboxBase) {\n  constructor() {\n    super(...arguments);\n    this.emphasized = false;\n  }\n  static get styles() {\n    if (window.hasOwnProperty(\"ShadyDOM\")) {\n      return [switchStyles, legacyStyles];\n    }\n    return [switchStyles];\n  }\n  render() {\n    return html`\n      ${super.render()}\n      <span id=\"switch\"></span>\n      <label id=\"label\" for=\"input\"><slot></slot></label>\n    `;\n  }\n  firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.inputElement.setAttribute(\"role\", \"switch\");\n  }\n  updated(changes) {\n    if (changes.has(\"checked\")) {\n      this.inputElement.setAttribute(\n        \"aria-checked\",\n        this.checked ? \"true\" : \"false\"\n      );\n    }\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Switch.prototype, \"emphasized\", 2);\n//# sourceMappingURL=Switch.dev.js.map\n","\"use strict\";\nimport { Theme } from \"../Theme.dev.js\";\nimport coreStyles from \"./theme.css.js\";\nTheme.registerThemeFragment(\"spectrum-two\", \"system\", coreStyles);\n//# sourceMappingURL=core.dev.js.map\n","\"use strict\";\nimport \"../src/spectrum-two/core.dev.js\";\nimport lightStyles from \"../src/spectrum-two/theme-light.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"light-spectrum-two\", \"color\", lightStyles);\n//# sourceMappingURL=theme-light.dev.js.map\n","\"use strict\";\nimport \"../src/spectrum-two/core.dev.js\";\nimport darkStyles from \"../src/spectrum-two/theme-dark.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"dark-spectrum-two\", \"color\", darkStyles);\n//# sourceMappingURL=theme-dark.dev.js.map\n","\"use strict\";\nimport \"../src/spectrum-two/core.dev.js\";\nimport mediumStyles from \"../src/spectrum-two/scale-medium.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"medium-spectrum-two\", \"scale\", mediumStyles);\n//# sourceMappingURL=scale-medium.dev.js.map\n","\"use strict\";\nimport \"../src/spectrum-two/core.dev.js\";\nimport largeStyles from \"../src/spectrum-two/scale-large.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"large-spectrum-two\", \"scale\", largeStyles);\n//# sourceMappingURL=scale-large.dev.js.map\n","\"use strict\";\nimport { Theme } from \"../Theme.dev.js\";\nimport coreStyles from \"./theme.css.js\";\nTheme.registerThemeFragment(\"express\", \"system\", coreStyles);\n//# sourceMappingURL=core.dev.js.map\n","\"use strict\";\nimport \"../src/express/core.dev.js\";\nimport lightStyles from \"../src/express/theme-light.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"light-express\", \"color\", lightStyles);\n//# sourceMappingURL=theme-light.dev.js.map\n","\"use strict\";\nimport \"../src/express/core.dev.js\";\nimport darkStyles from \"../src/express/theme-dark.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"dark-express\", \"color\", darkStyles);\n//# sourceMappingURL=theme-dark.dev.js.map\n","\"use strict\";\nimport \"../src/express/core.dev.js\";\nimport mediumStyles from \"../src/express/scale-medium.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"medium-express\", \"scale\", mediumStyles);\n//# sourceMappingURL=scale-medium.dev.js.map\n","\"use strict\";\nimport \"../src/express/core.dev.js\";\nimport largeStyles from \"../src/express/scale-large.css.js\";\nimport { Theme } from \"../src/Theme.dev.js\";\nTheme.registerThemeFragment(\"large-express\", \"scale\", largeStyles);\n//# sourceMappingURL=scale-large.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  css,\n  html,\n  nothing,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { DARK_MODE } from \"@spectrum-web-components/reactive-controllers/src/MatchMedia.js\";\nimport {\n  Theme\n} from \"@spectrum-web-components/theme\";\nimport \"@spectrum-web-components/theme/sp-theme.js\";\nimport \"@spectrum-web-components/theme/src/themes.js\";\nimport \"@spectrum-web-components/theme/src/spectrum-two/themes.js\";\nimport \"@spectrum-web-components/theme/src/express/themes.js\";\nimport \"@spectrum-web-components/field-label/sp-field-label.js\";\nimport \"@spectrum-web-components/picker/sp-picker.js\";\nimport \"@spectrum-web-components/menu/sp-menu.js\";\nimport \"@spectrum-web-components/menu/sp-menu-item.js\";\nimport \"@spectrum-web-components/switch/sp-switch.js\";\nimport \"./types.dev.js\";\nimport { Locales } from \"./locales.dev.js\";\nconst queryString = window.location.search;\nconst urlParams = new URLSearchParams(queryString);\nexport let dir = urlParams.get(\"sp_dir\") || \"ltr\";\nexport const theme = urlParams.get(\"sp_theme\") || \"spectrum\";\nexport let system = urlParams.get(\"sp_system\") || \"spectrum\";\nexport let color = urlParams.get(\"sp_color\") || (matchMedia(DARK_MODE).matches ? \"dark\" : \"light\");\nexport let scale = urlParams.get(\"sp_scale\") || \"medium\";\nexport let reduceMotion = urlParams.get(\"sp_reduceMotion\") === \"true\";\nexport const screenshot = urlParams.get(\"sp_screenshot\") === \"true\";\nexport const locale = urlParams.get(\"sp_locale\") || \"en-US\";\nexport const direction = urlParams.get(\"sp_direction\") || \"ltr\";\nwindow.__swc_hack_knobs__ = window.__swc_hack_knobs__ || {\n  defaultSystemVariant: system,\n  defaultColor: color,\n  defaultScale: scale,\n  defaultDirection: dir,\n  defaultReduceMotion: reduceMotion,\n  defaultLocale: locale\n};\nconst reduceMotionProperties = css`\n  --spectrum-animation-duration-0: 0ms;\n  --spectrum-animation-duration-100: 0ms;\n  --spectrum-animation-duration-200: 0ms;\n  --spectrum-animation-duration-300: 0ms;\n  --spectrum-animation-duration-400: 0ms;\n  --spectrum-animation-duration-500: 0ms;\n  --spectrum-animation-duration-600: 0ms;\n  --spectrum-animation-duration-700: 0ms;\n  --spectrum-animation-duration-800: 0ms;\n  --spectrum-animation-duration-900: 0ms;\n  --spectrum-animation-duration-1000: 0ms;\n  --spectrum-animation-duration-2000: 0ms;\n  --spectrum-animation-duration-4000: 0ms;\n  --spectrum-animation-duration-6000: 0ms;\n  --pending-delay: 0s;\n  --spectrum-coachmark-animation-indicator-ring-duration: 0ms;\n  --swc-test-duration: 1ms;\n`;\nexport class StoryDecorator extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.system = window.__swc_hack_knobs__.defaultSystemVariant;\n    this.color = window.__swc_hack_knobs__.defaultColor;\n    this.scale = window.__swc_hack_knobs__.defaultScale;\n    this.direction = window.__swc_hack_knobs__.defaultDirection;\n    this.reduceMotion = window.__swc_hack_knobs__.defaultReduceMotion;\n    this.lang = window.__swc_hack_knobs__.defaultLocale;\n    this.screenshot = screenshot;\n    this.ready = false;\n  }\n  static get styles() {\n    return [\n      css`\n        :host(:focus) {\n          outline: none;\n        }\n        sp-theme {\n          overflow-x: hidden;\n          display: block;\n          box-sizing: border-box;\n          width: 100%;\n          min-height: 100vh;\n          padding: var(--decorator-padding-100) var(--decorator-padding-100)\n            calc(\n              2 * var(--spectrum-focus-indicator-thickness) +\n                var(--spectrum-component-height-100)\n            );\n          box-sizing: border-box;\n          background-color: var(--spectrum-background-base-color);\n          color: var(--spectrum-body-color);\n\n          --decorator-padding-100: calc(\n            var(--swc-scale-factor, 1) * var(--spectrum-spacing-100)\n          );\n          --decorator-padding-200: calc(\n            var(--swc-scale-factor, 1) * var(--spectrum-spacing-200)\n          );\n          --decorator-padding-400: calc(\n            var(--swc-scale-factor, 1) * var(--spectrum-spacing-400)\n          );\n        }\n        :host([screenshot]) sp-theme {\n          padding: var(--decorator-padding-100);\n        }\n        :host([reduce-motion]) sp-theme {\n          ${reduceMotionProperties}\n        }\n        .manage-theme {\n          position: fixed;\n          bottom: 0;\n          left: var(--decorator-padding-200);\n          right: var(--decorator-padding-200);\n          display: flex;\n          align-items: flex-start;\n          justify-content: flex-end;\n          box-sizing: border-box;\n          padding-bottom: calc(2 * var(--spectrum-alias-focus-ring-size));\n        }\n        sp-field-label {\n          padding-inline-end: var(\n            --spectrum-fieldlabel-side-padding-x,\n            var(--decorator-padding-100)\n          );\n          margin-inline-start: var(--decorator-padding-400);\n        }\n        sp-switch {\n          margin-inline-start: var(--decorator-padding-400);\n        }\n      `\n    ];\n  }\n  updateTheme({ target }) {\n    const { id } = target;\n    const { value } = target;\n    const { checked } = target;\n    switch (id) {\n      case \"system\":\n        this.system = system = window.__swc_hack_knobs__.defaultSystemVariant = value;\n        break;\n      case \"color\":\n        this.color = color = window.__swc_hack_knobs__.defaultColor = value;\n        break;\n      case \"scale\":\n        this.scale = scale = window.__swc_hack_knobs__.defaultScale = value;\n        break;\n      case \"dir\":\n        this.direction = dir = window.__swc_hack_knobs__.defaultDirection = value;\n        if (document.documentElement.dir !== dir) {\n          document.documentElement.dir = dir;\n        }\n        requestAnimationFrame(() => {\n          window.dispatchEvent(new Event(\"resize\"));\n        });\n        break;\n      case \"reduceMotion\":\n        this.reduceMotion = reduceMotion = window.__swc_hack_knobs__.defaultReduceMotion = checked;\n        break;\n      case \"locale\":\n        this.lang = window.__swc_hack_knobs__.defaultLocale = value;\n        break;\n    }\n  }\n  get backgroundStyle() {\n    if (this.system === \"spectrum-two\") {\n      return `background-color: var(--spectrum-gray-50)`;\n    }\n    return `background-color: var(--spectrum-gray-100);`;\n  }\n  handleKeydown(event) {\n    const path = event.composedPath();\n    const hasInput = path.some(\n      (node) => node instanceof HTMLInputElement || node instanceof HTMLTextAreaElement || !!node.isContentEditable\n    );\n    if (hasInput) {\n      event.stopPropagation();\n    }\n  }\n  render() {\n    return html`\n      <sp-theme\n        system=${this.system}\n        color=${this.color}\n        scale=${this.scale}\n        dir=${this.direction}\n        style=${this.backgroundStyle}\n        part=\"container\"\n        lang=${this.lang}\n        @keydown=${this.handleKeydown}\n      >\n        <slot @slotchange=${this.checkReady}></slot>\n        ${this.screenshot ? nothing : this.manageTheme}\n      </sp-theme>\n    `;\n  }\n  async checkReady({\n    target\n  }) {\n    this.ready = false;\n    const assignedElements = target.assignedElements({\n      flatten: true\n    });\n    const descendents = assignedElements;\n    assignedElements.forEach((descendent) => {\n      const gathered = [\n        ...descendent.querySelectorAll(\"*\") || []\n      ];\n      descendents.push(...gathered);\n    });\n    const litElementDescendents = descendents.filter(\n      (el) => el.tagName.search(\"-\") !== -1 && typeof el.updateComplete !== \"undefined\"\n    );\n    const updates = litElementDescendents.map((el) => el.updateComplete);\n    await Promise.all(updates);\n    new Promise((res) => {\n      setTimeout(res);\n    }).then(async () => {\n      await (document.fonts ? document.fonts.ready : Promise.resolve());\n      setTimeout(() => {\n        this.ready = true;\n      });\n    });\n  }\n  get manageTheme() {\n    return html`\n      <div class=\"manage-theme\" part=\"controls\">\n        ${this.systemControl} ${this.colorControl} ${this.scaleControl}\n        ${this.localeControl} ${this.dirControl} ${this.reduceMotionControl}\n      </div>\n    `;\n  }\n  get systemControl() {\n    return html`\n      <sp-field-label side-aligned=\"start\" for=\"system\">System</sp-field-label>\n      <sp-picker\n        id=\"system\"\n        placement=\"top\"\n        quiet\n        .value=${this.system}\n        @change=${this.updateTheme}\n      >\n        <sp-menu-item value=\"spectrum\">Spectrum</sp-menu-item>\n        <sp-menu-item value=\"express\">Express</sp-menu-item>\n        <sp-menu-item value=\"spectrum-two\">Spectrum 2</sp-menu-item>\n      </sp-picker>\n    `;\n  }\n  get colorControl() {\n    return html`\n      <sp-field-label side-aligned=\"start\" for=\"color\">Theme</sp-field-label>\n      <sp-picker\n        id=\"color\"\n        placement=\"top\"\n        quiet\n        .value=${this.color}\n        @change=${this.updateTheme}\n      >\n        <sp-menu-item value=\"light\">Light</sp-menu-item>\n        <sp-menu-item value=\"dark\">Dark</sp-menu-item>\n      </sp-picker>\n    `;\n  }\n  get scaleControl() {\n    return html`\n      <sp-field-label side-aligned=\"start\" for=\"scale\">Scale</sp-field-label>\n      <sp-picker\n        id=\"scale\"\n        label=\"Scale\"\n        placement=\"top\"\n        quiet\n        .value=${this.scale}\n        @change=${this.updateTheme}\n      >\n        <sp-menu-item value=\"medium\">Medium</sp-menu-item>\n        <sp-menu-item value=\"large\">Large</sp-menu-item>\n      </sp-picker>\n    `;\n  }\n  get localeControl() {\n    const renderLocaleOption = (locale2) => html`\n      <sp-menu-item value=${locale2}>${Locales[locale2]}</sp-menu-item>\n    `;\n    return html`\n      <sp-field-label side-aligned=\"start\" for=\"locale\">Locale</sp-field-label>\n      <sp-picker\n        id=\"locale\"\n        label=\"Locale\"\n        placement=\"top\"\n        quiet\n        .value=${this.lang}\n        @change=${this.updateTheme}\n      >\n        ${Object.keys(Locales).map(renderLocaleOption)}\n      </sp-picker>\n    `;\n  }\n  get dirControl() {\n    return html`\n      <sp-field-label side-aligned=\"start\" for=\"dir\">Direction</sp-field-label>\n      <sp-picker\n        id=\"dir\"\n        label=\"Direction\"\n        placement=\"top\"\n        quiet\n        .value=${this.direction}\n        @change=${this.updateTheme}\n      >\n        <sp-menu-item value=\"ltr\">LTR</sp-menu-item>\n        <sp-menu-item value=\"rtl\">RTL</sp-menu-item>\n      </sp-picker>\n    `;\n  }\n  get reduceMotionControl() {\n    return html`\n      <sp-switch\n        id=\"reduceMotion\"\n        ?checked=${this.reduceMotion}\n        @change=${this.updateTheme}\n      >\n        Reduce motion\n      </sp-switch>\n    `;\n  }\n  willUpdate(changes) {\n    if (changes.has(\"screenshot\") && this.screenshot) {\n      Theme.registerThemeFragment(\n        \"app\",\n        \"app\",\n        css`\n          :host {\n            --swc-test-caret-color: transparent;\n            --swc-test-forced-color-adjust: none;\n          }\n        `\n      );\n    }\n  }\n}\n__decorateClass([\n  property({ type: String })\n], StoryDecorator.prototype, \"system\", 2);\n__decorateClass([\n  property({ type: String })\n], StoryDecorator.prototype, \"color\", 2);\n__decorateClass([\n  property({ type: String })\n], StoryDecorator.prototype, \"scale\", 2);\n__decorateClass([\n  property({ type: String, reflect: true, attribute: \"dir\" })\n], StoryDecorator.prototype, \"direction\", 2);\n__decorateClass([\n  property({ type: Boolean, attribute: \"reduce-motion\", reflect: true })\n], StoryDecorator.prototype, \"reduceMotion\", 2);\n__decorateClass([\n  property({ type: String })\n], StoryDecorator.prototype, \"lang\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], StoryDecorator.prototype, \"screenshot\", 2);\n//# sourceMappingURL=StoryDecorator.dev.js.map\n","\"use strict\";\nimport { useEffect } from \"@storybook/preview-api\";\nimport { html } from \"@spectrum-web-components/base\";\nimport \"./sp-story-decorator.dev.js\";\nexport const themeStyles = html`\n  <style>\n    #root {\n      padding: 0;\n    }\n    sp-story-decorator::part(controls) {\n      position: absolute;\n    }\n  </style>\n`;\nexport const swcThemeDecorator = (story, context) => {\n  const {\n    globals: { system, color, scale, textDirection, reduceMotion, lang } = {}\n  } = context;\n  useEffect(() => {\n    if (system) {\n      window.__swc_hack_knobs__.defaultSystemVariant = system;\n    }\n    if (color) {\n      window.__swc_hack_knobs__.defaultColor = color;\n    }\n    if (scale) {\n      window.__swc_hack_knobs__.defaultScale = scale;\n    }\n    if (textDirection) {\n      window.__swc_hack_knobs__.defaultDirection = textDirection;\n      if (document.documentElement.dir !== textDirection) {\n        document.documentElement.dir = textDirection;\n        requestAnimationFrame(() => {\n          window.dispatchEvent(new Event(\"resize\"));\n        });\n      }\n    }\n    if (reduceMotion !== void 0) {\n      window.__swc_hack_knobs__.defaultReduceMotion = reduceMotion;\n    }\n    if (lang) {\n      window.__swc_hack_knobs__.defaultLocale = lang;\n    }\n  }, [system, color, scale, textDirection, reduceMotion, lang]);\n  const hasAnySetting = system || color || scale || textDirection || reduceMotion;\n  return html`\n    <style>\n      #root {\n          padding: 0;\n      }\n      sp-story-decorator::part(controls) {\n          position: absolute;\n      }\n      ${hasAnySetting ? `sp-story-decorator::part(controls) {\n                display: none;\n            }\n        ` : \"\"}\n    </style>\n    <sp-story-decorator\n      role=\"main\"\n      system=${system}\n      color=${color}\n      scale=${scale}\n      lang=${lang}\n      .direction=${textDirection}\n      ?reduce-motion=${reduceMotion}\n    >\n      ${story({}, context)}\n    </sp-story-decorator>\n  `;\n};\n//# sourceMappingURL=decorator.dev.js.map\n","/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { swcThemeDecorator } from '@spectrum-web-components/story-decorator/decorator.js';\nimport { Locales } from '@spectrum-web-components/story-decorator/src/locales.js';\n\nimport '@spectrum-web-components/story-decorator/sp-story-decorator.js';\n\n// import { setCustomElementsManifest } from '@storybook/web-components';\nimport DocumentationTemplate from './DocumentationTemplate.mdx';\n\n/**\n * Ensure that window.__swc is defined in the storybook runtime.\n *\n * This prevents debug-only calls like `window.__swc.warn(...)` from throwing\n * when the debug flag is inlined to `true` by the dev build configuration.\n */\nif (typeof window !== 'undefined') {\n  window.__swc = window.__swc || {};\n  if (typeof window.__swc.DEBUG === 'undefined') {\n    window.__swc.DEBUG = true;\n  }\n  if (typeof window.__swc.warn !== 'function') {\n    window.__swc.warn = (...args) => {\n      // Forward warnings to the console for visibility in storybook.\n      console.warn('[SWC]', ...args);\n    };\n  }\n}\n\n// const cem = await import('./custom-elements.json', {\n//     assert: { type: 'json' },\n// });\n\n// setCustomElementsManifest(cem);\n\nexport const globalTypes = {\n  system: {\n    title: 'Design context',\n    description: 'The variation of Spectrum to use in the component',\n    defaultValue: 'spectrum',\n    type: 'string',\n    showName: true,\n    toolbar: {\n      items: [\n        {\n          value: 'spectrum-two',\n          title: 'Spectrum 2',\n          right: 'default',\n        },\n        { value: 'spectrum', title: 'Spectrum 1', right: 'legacy' },\n        { value: 'express', title: 'Express' },\n      ],\n      dynamicTitle: true,\n    },\n  },\n  color: {\n    title: 'Color',\n    description: 'Controls the color context of the component',\n    defaultValue: 'light',\n    icon: 'paintbrush',\n    type: 'string',\n    toolbar: {\n      items: [\n        { value: 'light', title: 'Light', right: 'default' },\n        { value: 'dark', title: 'Dark' },\n      ],\n      dynamicTitle: true,\n    },\n  },\n  scale: {\n    title: 'Platform scale',\n    description: 'Controls the platform scale of the component',\n    defaultValue: 'medium',\n    type: 'string',\n    toolbar: {\n      items: [\n        {\n          value: 'medium',\n          title: 'Medium',\n          right: 'default',\n          icon: 'browser',\n        },\n        { value: 'large', title: 'Large', icon: 'mobile' },\n      ],\n      dynamicTitle: true,\n    },\n  },\n  textDirection: {\n    title: 'Text direction',\n    description: 'Direction of the content flow',\n    defaultValue: 'ltr',\n    type: 'string',\n    toolbar: {\n      items: [\n        { value: 'ltr', title: 'Left to right' },\n        { value: 'rtl', title: 'Right to left' },\n      ],\n      dynamicTitle: true,\n    },\n  },\n  lang: {\n    title: 'Language',\n    description: 'Language of the content',\n    defaultValue: 'en-US',\n    type: 'string',\n    toolbar: {\n      items: Object.entries(Locales).map(([key, value]) => ({\n        value: key,\n        title: value,\n      })),\n      dynamicTitle: true,\n    },\n  },\n  reducedMotion: {\n    title: 'Reduce motion',\n    description: 'Reduce animation and transitions',\n    defaultValue: false,\n    type: 'boolean',\n    toolbar: {\n      items: [\n        { value: false, title: 'Default', icon: 'play' },\n        { value: true, title: 'Reduced motion', icon: 'stop' },\n      ],\n      dynamicTitle: true,\n    },\n  },\n};\n\nexport const parameters = {\n  docs: {\n    template: DocumentationTemplate,\n  },\n  controls: {\n    expanded: true,\n    matchers: {\n      color: /(backgroundColor|color)$/i,\n      date: /Date$/,\n    },\n  },\n  layout: 'fullscreen',\n  options: {\n    storySort: {\n      method: 'alphabetical-by-kind',\n    },\n  },\n  badgesConfig: {\n    deprecated: {\n      styles: {\n        backgroundColor: '#FFF',\n        borderColor: '#ea3829',\n        color: '#ea3829',\n      },\n      title: 'Deprecated',\n    },\n  },\n  chromatic: {\n    forcedColors: 'none',\n    prefersReducedMotion: 'no-preference',\n    pauseAnimationAtEnd: true,\n    modes: {\n      'Context: Spectrum 1': {\n        scale: 'medium',\n        color: 'light',\n        textDirection: 'ltr',\n        context: 'spectrum1',\n      },\n      'Context: Express': {\n        context: 'express',\n      },\n      'Dark | RTL': {\n        color: 'dark',\n        textDirection: 'rtl',\n      },\n    },\n  },\n};\n\nexport const decorators = [swcThemeDecorator];\n\nexport const tags = ['autodocs'];\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html\n} from \"@spectrum-web-components/base\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { ifDefined } from \"@spectrum-web-components/base/src/directives.js\";\nexport function LikeAnchor(constructor) {\n  class LikeAnchorElement extends constructor {\n    renderAnchor({\n      id,\n      className,\n      ariaHidden,\n      labelledby,\n      tabindex,\n      // prettier-ignore\n      anchorContent = html`<slot></slot>`\n    }) {\n      return html`<a\n                    id=${id}\n                    class=${ifDefined(className)}\n                    href=${ifDefined(this.href)}\n                    download=${ifDefined(this.download)}\n                    target=${ifDefined(this.target)}\n                    aria-label=${ifDefined(this.label)}\n                    aria-labelledby=${ifDefined(labelledby)}\n                    aria-hidden=${ifDefined(ariaHidden ? \"true\" : void 0)}\n                    tabindex=${ifDefined(tabindex)}\n                    referrerpolicy=${ifDefined(this.referrerpolicy)}\n                    rel=${ifDefined(this.rel)}\n                >${anchorContent}</a>`;\n    }\n  }\n  __decorateClass([\n    property()\n  ], LikeAnchorElement.prototype, \"download\", 2);\n  __decorateClass([\n    property()\n  ], LikeAnchorElement.prototype, \"label\", 2);\n  __decorateClass([\n    property()\n  ], LikeAnchorElement.prototype, \"href\", 2);\n  __decorateClass([\n    property()\n  ], LikeAnchorElement.prototype, \"target\", 2);\n  __decorateClass([\n    property()\n  ], LikeAnchorElement.prototype, \"referrerpolicy\", 2);\n  __decorateClass([\n    property()\n  ], LikeAnchorElement.prototype, \"rel\", 2);\n  return LikeAnchorElement;\n}\n//# sourceMappingURL=like-anchor.dev.js.map\n","\"use strict\";\nimport \"./core.dev.js\";\nimport { Theme } from \"./src/Theme.dev.js\";\nimport lightStyles from \"./src/theme-light.css.js\";\nTheme.registerThemeFragment(\"light\", \"color\", lightStyles);\n//# sourceMappingURL=theme-light.dev.js.map\n","\"use strict\";\nimport \"./core.dev.js\";\nimport { Theme } from \"./src/Theme.dev.js\";\nimport lightestStyles from \"./src/theme-lightest.css.js\";\nTheme.registerThemeFragment(\"lightest\", \"color\", lightestStyles);\n//# sourceMappingURL=theme-lightest.dev.js.map\n","\"use strict\";\nimport \"./core.dev.js\";\nimport { Theme } from \"./src/Theme.dev.js\";\nimport darkStyles from \"./src/theme-dark.css.js\";\nTheme.registerThemeFragment(\"dark\", \"color\", darkStyles);\n//# sourceMappingURL=theme-dark.dev.js.map\n","\"use strict\";\nimport \"./core.dev.js\";\nimport { Theme } from \"./src/Theme.dev.js\";\nimport darkStyles from \"./src/theme-darkest.css.js\";\nTheme.registerThemeFragment(\"darkest\", \"color\", darkStyles);\n//# sourceMappingURL=theme-darkest.dev.js.map\n","\"use strict\";\nimport \"./core.dev.js\";\nimport mediumStyles from \"./src/scale-medium.css.js\";\nimport { Theme } from \"./src/Theme.dev.js\";\nTheme.registerThemeFragment(\"medium\", \"scale\", mediumStyles);\n//# sourceMappingURL=scale-medium.dev.js.map\n","\"use strict\";\nimport \"./core.dev.js\";\nimport largeStyles from \"./src/scale-large.css.js\";\nimport { Theme } from \"./src/Theme.dev.js\";\nTheme.registerThemeFragment(\"large\", \"scale\", largeStyles);\n//# sourceMappingURL=scale-large.dev.js.map\n"],"names":[],"sourceRoot":""}